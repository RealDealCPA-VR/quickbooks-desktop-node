export interface AccountAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen.

  For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The type of QuickBooks account. You cannot create or modify a non-posting account through the SDK, because QuickBooks creates these accounts behind the scenes. This means that you cannot send an `AccountAdd` request with an `AccountType` of `NonPosting`. */
  AccountType: AccountType;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** The bank account number or an identifying note about the account. If a `BankNumber` exists in a QuickBooks company file, it will only be returned to applications that have been granted permission to access sensitive data and that are using SDK v2.0 or greater. */
  BankNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** The amount of money in, or the value of, this account as of `OpenBalanceDate`. On a bank statement, the amount of money in the account at the beginning of the statement period. */
  OpenBalance?: string;
  /** The date when an opening balance was entered for this account. */
  OpenBalanceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** An internal representation of the tax line associated with this account. */
  TaxLineID?: number;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface AccountAddRq {
  AccountAdd: AccountAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface AccountAddRs {
  AccountRet?: AccountRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface AccountantCopy {
  /** Indicates whether an accountant copy has been made for this company file, with a value of true meaning a copy has been made and a value of false meaning there is no accountant copy. */
  AccountantCopyExists: boolean;
  /** The dividing date indicates the fiscal period within which the accountant is working. This date is key because as long as the accountant copy exists, no transactions can be modified or created within that period. You can add new accounts, but you cannot add new subaccounts to existing accounts, and you cannot edit, merge, or make an existing account inactive. Finally, you cannot delete or merge list items. */
  DividingDate?: string;
}

export interface AccountFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`.

  A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

export interface AccountMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen.

  For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The type of QuickBooks account. You cannot create or modify a non-posting account through the SDK, because QuickBooks creates these accounts behind the scenes. This means that you cannot send an `AccountAdd` request with an `AccountType` of `NonPosting`. */
  AccountType?: AccountType;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** The bank account number or an identifying note about the account. If a `BankNumber` exists in a QuickBooks company file, it will only be returned to applications that have been granted permission to access sensitive data and that are using SDK v2.0 or greater. */
  BankNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** The amount of money in, or the value of, this account as of `OpenBalanceDate`. On a bank statement, the amount of money in the account at the beginning of the statement period. */
  OpenBalance?: string;
  /** The date when an opening balance was entered for this account. */
  OpenBalanceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** An internal representation of the tax line associated with this account. */
  TaxLineID?: number;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface AccountModRq {
  AccountMod: AccountMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface AccountModRs {
  AccountRet?: AccountRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface AccountQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`.

  A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.

  For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).

  For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.

  For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).

  For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** A list of QuickBooks account types. */
  AccountType?: AccountType | AccountType[];
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension: If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI. If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI.

  Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters.

  When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface AccountQueryRs {
  AccountRet: AccountRet[];
}

export interface AccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface AccountRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen.

  For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The type of QuickBooks account. You cannot create or modify a non-posting account through the SDK, because QuickBooks creates these accounts behind the scenes. This means that you cannot send an `AccountAdd` request with an `AccountType` of `NonPosting`. */
  AccountType: AccountType;
  /** If `SpecialAccountType` returns a value, then QuickBooks automatically created this account when it was needed. Some special accounts cannot be overridden, because QuickBooks uses them exclusively for special purposes. */
  SpecialAccountType?: SpecialAccountType;
  /** Indicates whether the account is used for tax. */
  IsTaxAccount?: boolean;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** The bank account number or an identifying note about the account. If a `BankNumber` exists in a QuickBooks company file, it will only be returned to applications that have been granted permission to access sensitive data and that are using SDK v2.0 or greater. */
  BankNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** Current balance of this account only (versus `TotalBalance`). Income accounts and balance sheet accounts do not necessarily have balances. */
  Balance?: string;
  /** The balance for this object and all its subordinate objects. For example, the `TotalBalance` for XYZ Bank would be the total of the balances of all its subaccounts (checking, savings, and so on). If XYZ Bank did not have any subaccounts, `TotalBalance` and `Balance` would be the same. */
  TotalBalance?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** If the QuickBooks user has associated a tax form with this company file, they can also associate each account in the company file with a line of that tax form. (To check which tax form, if any, is associated with this company file, do a `CompanyQuery` and check the returned `TaxForm` value.) */
  TaxLineInfoRet?: TaxLineInfoRet;
  /** Indicates how this account is classified for cash flow reporting. If the value is `cfcNone`, the account has not been classified. If the value is `cfcNotApplicable`, the account does not qualify to be classified. (For example, a bank account that tracks cash transactions is not part of a cash flow report.) */
  CashFlowClassification?: CashFlowClassification;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export type AccountType =
  | "AccountsPayable"
  | "AccountsReceivable"
  | "Bank"
  | "CostOfGoodsSold"
  | "CreditCard"
  | "Equity"
  | "Expense"
  | "FixedAsset"
  | "Income"
  | "LongTermLiability"
  | "NonPosting"
  | "OtherAsset"
  | "OtherCurrentAsset"
  | "OtherCurrentLiability"
  | "OtherExpense"
  | "OtherIncome";

export type AccountTypeFilter =
  | "AccountsPayable"
  | "AccountsReceivable"
  | "AllowedFor1099"
  | "APAndSalesTax"
  | "APOrCreditCard"
  | "ARAndAP"
  | "Asset"
  | "BalanceSheet"
  | "Bank"
  | "BankAndARAndAPAndUF"
  | "BankAndUF"
  | "CostOfSales"
  | "CreditCard"
  | "CurrentAsset"
  | "CurrentAssetAndExpense"
  | "CurrentLiability"
  | "Equity"
  | "EquityAndIncomeAndExpense"
  | "ExpenseAndOtherExpense"
  | "FixedAsset"
  | "IncomeAndExpense"
  | "IncomeAndOtherIncome"
  | "Liability"
  | "LiabilityAndEquity"
  | "LongTermLiability"
  | "NonPosting"
  | "OrdinaryExpense"
  | "OrdinaryIncome"
  | "OrdinaryIncomeAndCOGS"
  | "OrdinaryIncomeAndExpense"
  | "OtherAsset"
  | "OtherCurrentAsset"
  | "OtherCurrentLiability"
  | "OtherExpense"
  | "OtherIncome"
  | "OtherIncomeOrExpense";

export type AccrualPeriod =
  | "BeginningOfYear"
  | "EveryHourOnPaycheck"
  | "EveryPaycheck";

export type AcquiredAs = "New" | "Old";

/** @default: ActiveOnly */
export type ActiveStatus = "ActiveOnly" | "All" | "InactiveOnly";

export interface AdditionalContactRef {
  /** The name of the contact. */
  ContactName: string;
  /** The value of the contact field. */
  ContactValue: string;
}

export interface AdditionalNotes {
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note: string;
}

export interface AdditionalNotesMod {
  /** The ID of the note. */
  NoteID: number;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note: string;
}

export interface AdditionalNotesRet {
  /** The ID of the note. */
  NoteID: number;
  /** The date the note was updated. */
  Date: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note: string;
}

export interface Address {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface AddressBlock {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export type AdjustBillingRateRelativeTo = "CurrentCustomRate" | "StandardRate";

export type AdjustRelativeTo = "Cost" | "CurrentCustomPrice" | "StandardPrice";

export interface APAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface AppliedToTxnAdd {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Represents the amount assigned to a particular receivable. The sum of all `PaymentAmount` elements in any given receive payment transaction must not be greater than `TotalAmount`. */
  PaymentAmount?: string;
  /** A list of credits to set. Setting, or applying, a credit means using an available credit to lower the balance of a transaction such as an invoice or a bill. (Creating a credit, on the other hand, means making a credit available to be applied in the future.) Notice that if you use a credit (`SetCredit`) only, in your `ReceivePaymentAdd` or `BillPaymentCreditCardAdd` request, then no transaction ID is created, because, from the viewpoint of QuickBooks, there was no transaction. Setting a credit merely creates links between existing transactions (for example, between a credit memo transaction and an invoice transaction), and no information about these links will be returned to you in the response. If you need to retrieve which transactions were linked in the `SetCredit`, for Bill Payment, you must do a `BillQuery` and specify `IncludeLinkedTxns`. */
  SetCredit?: SetCredit | SetCredit[];
  /** Reduces the receivable amount. */
  DiscountAmount?: string;
  /** Refers to the account where this discount is tracked. In a request, if a `DiscountAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DiscountAccountRef?: DiscountAccountRef;
  /** Class reference used in the Discount object. */
  DiscountClassRef?: DiscountClassRef;
}

export interface AppliedToTxnMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Represents the amount assigned to a particular receivable. The sum of all `PaymentAmount` elements in any given receive payment transaction must not be greater than `TotalAmount`. */
  PaymentAmount?: string;
  /** A list of credits to set. Setting, or applying, a credit means using an available credit to lower the balance of a transaction such as an invoice or a bill. (Creating a credit, on the other hand, means making a credit available to be applied in the future.)

  Notice that if you use a credit (`SetCredit`) only, in your `ReceivePaymentAdd` or `BillPaymentCreditCardAdd` request, then no transaction ID is created, because, from the viewpoint of QuickBooks, there was no transaction. Setting a credit merely creates links between existing transactions (for example, between a credit memo transaction and an invoice transaction), and no information about these links will be returned to you in the response.

  If you need to retrieve which transactions were linked in the `SetCredit`, for Bill Payment, you must do a `BillQuery` and specify `IncludeLinkedTxns`. */
  SetCredit?: SetCredit | SetCredit[];
  /** Reduces the receivable amount. */
  DiscountAmount?: string;
  /** Refers to the account where this discount is tracked. In a request, if a `DiscountAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DiscountAccountRef?: DiscountAccountRef;
  /** Class reference used in the Discount object. */
  DiscountClassRef?: DiscountClassRef;
}

export interface AppliedToTxnRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** The type of transaction. */
  TxnType: TxnType;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** The outstanding balance on this invoice. `BalanceRemaining` = (`Subtotal` + `SalesTaxTotal`) – `AppliedAmount`. */
  BalanceRemaining?: string;
  /** A monetary amount. */
  Amount?: string;
  /** Reduces the receivable amount. */
  DiscountAmount?: string;
  /** Refers to the account where this discount is tracked. In a request, if a `DiscountAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DiscountAccountRef?: DiscountAccountRef;
  /** Class reference used in the Discount object. */
  DiscountClassRef?: DiscountClassRef;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty.

  The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
}

export interface ApplyCheckToTxnAdd {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A monetary amount. */
  Amount?: string;
}

export interface ApplyCheckToTxnMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A monetary amount. */
  Amount?: string;
}

export interface ARAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface AssetAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type AVSStreet = "Fail" | "NotAvailable" | "Pass";

export type AVSZip = "Fail" | "NotAvailable" | "Pass";

export interface BankAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface BarCode {
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** Allow barcode to be assigned to item, even if already in use. */
  AssignEvenIfUsed?: boolean;
  /** Allows for barcode to be overridden for an item. */
  AllowOverride?: boolean;
}

export type BillableStatus = "Billable" | "HasBeenBilled" | "NotBillable";

export interface BillAdd {
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef: VendorRef;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.)

  If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** Appears in the A/P register and in reports that include this bill. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** The `LinkToTxnID` aggregate allows to link an entire transaction. If you want to link individual lines in a transaction, use the `LinkToTxn` aggregate.

  You can use both `LinkToTxnID` and `LinkToTxn` aggregates in the same request, as long as these aggregates do NOT link to the same `TxnID`. If both aggregates are used and do link to the same `TxnID`, you receive an error 3000. Also, if you attempt to invoke `LinkToTxnID` with the same `TxnID`, more than once, you get an error 3177. If the transaction specified by `LinkToTxnID` is already closed or fully received and the `ItemReceiptAdd` request does not contain any other lines, you get error 3180 for attempting to save an empty transaction. You get a warning if you attempt to link to a transaction that’s already closed. */
  LinkToTxnID?: string[] | string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineAdd?: ExpenseLineAdd | ExpenseLineAdd[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineAdd?: ItemLineAdd | ItemLineAdd[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineAdd?: ItemGroupLineAdd | ItemGroupLineAdd[];
}

export interface BillAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface BillAddressBlock {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface BillAddRq {
  BillAdd: BillAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BillAddRs {
  BillRet?: BillRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BillingRateAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** You use `FixedBillingRate` if you want the rate to override all service items rates. Consequently, there is no need to specify any service items (and in fact you can’t specify them) if you use this element. */
  FixedBillingRate?: string;
  /** If you don’t use `FixedBillingRate` to apply your billing rate to all service items, you need to use the `BillingRatePerItemList` with at least one `IBillingRatePerItem` object appended to it. Each `IBillingRatePerItem` object specifies the service item that your billing rate will operate on. You can append as many `IBillingRatePerItem` objects to the list as you want. */
  BillingRatePerItem?: BillingRatePerItem | BillingRatePerItem[];
}

export interface BillingRateAddRq {
  BillingRateAdd: BillingRateAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BillingRateAddRs {
  BillingRateRet?: BillingRateRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BillingRatePerItem {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** The value specified here overrides the rate of the service item referenced in this aggregate (in the `ItemRef`) with the rate you specify here. If instead you wanted a rate that is a percentage higher or lower than the service item rate, you wouldn’t use `CustomRate`, but you would use `AdjustPercentage` and `AdjustBillingRateRelativeTo`. */
  CustomRate?: string;
  /** Using this field with `BillingRateAdd` will work only if the service item itself is set to a percentage, not to an amount. If you attempt to set the Billing `Rate` to a percentage for a service item that has an amount for the `Rate`, you will get an error. The kind of rate you have on the service item determines the kind of billing rate you may have on that item. */
  CustomRatePercent?: string;
  /** If you don’t want to apply a custom price (for price levels) or custom rate (for billing rates), you can apply an adjusted price discount using the pair of fields `AdjustPercentage` and `AdjustRelativeTo` (`AdjustBillingRateRelativeTo` for billing rates). You specify the percentage discount or increase in the `AdjustPercentage` field and the price/rate to be discounted (standard item price, item cost, or the item’s current custom price) in the `AdjustRelativeTo` `fieldTo` field. Notice that this value supports both positive and negative values. For example, a value of 20 would increase the price by 20% and value of -10 would decrease the price by 10%. */
  AdjustPercentage: string;
  /** Specifies the service item rate that `AdjustPercentage` is applied to. Normally, this is set to `StandardRate`. */
  AdjustBillingRateRelativeTo: AdjustBillingRateRelativeTo;
}

export interface BillingRatePerItemRet {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** The value specified here overrides the rate of the service item referenced in this aggregate (in the `ItemRef`) with the rate you specify here. If instead you wanted a rate that is a percentage higher or lower than the service item rate, you wouldn’t use `CustomRate`, but you would use `AdjustPercentage` and `AdjustBillingRateRelativeTo`. */
  CustomRate?: string;
  /** Using this field with `BillingRateAdd` will work only if the service item itself is set to a percentage, not to an amount. If you attempt to set the Billing `Rate` to a percentage for a service item that has an amount for the `Rate`, you will get an error. The kind of rate you have on the service item determines the kind of billing rate you may have on that item. */
  CustomRatePercent?: string;
}

export interface BillingRateQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BillingRateQueryRs {
  BillingRateRet: BillingRateRet[];
}

export interface BillingRateRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface BillingRateRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Indicates whether the billing rate is a fixed rate or applies to specific service items. */
  BillingRateType?: BillingRateType;
  /** You use `FixedBillingRate` if you want the rate to override all service items rates. Consequently, there is no need to specify any service items (and in fact you can’t specify them) if you use this element. */
  FixedBillingRate?: string;
  /** If you don’t use `FixedBillingRate` to apply your billing rate to all service items, you need to use the `BillingRatePerItemList` with at least one `IBillingRatePerItem` object appended to it. Each `IBillingRatePerItem` object specifies the service item that your billing rate will operate on. You can append as many `IBillingRatePerItem` objects to the list as you want. */
  BillingRatePerItemRet?: BillingRatePerItemRet | BillingRatePerItemRet[];
}

export type BillingRateType = "FixedRate" | "PerItem";

export interface BillMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef?: VendorRef;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.)

  If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** Appears in the A/P register and in reports that include this bill. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Set `ClearExpenseLines` to true to clear all the expense lines. To modify individual lines, use `ExpenseLineMod`. */
  ClearExpenseLines?: boolean;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineMod?: ExpenseLineMod | ExpenseLineMod[];
  /** Set `ClearItemLines` to true to clear all the item lines. To modify individual lines, use `ItemLineMod`. */
  ClearItemLines?: boolean;
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineMod?: ItemGroupLineMod | ItemGroupLineMod[];
}

export interface BillModRq {
  BillMod: BillMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BillModRs {
  BillRet?: BillRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BillPaymentCheckAdd {
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef: PayeeEntityRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.) If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. If a `BankAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  BankAccountRef: BankAccountRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** `AppliedToTxn` List A list of `AppliedToTxn` aggregates. */
  AppliedToTxnAdd: AppliedToTxnAdd | AppliedToTxnAdd[];
}

export interface BillPaymentCheckAddRq {
  BillPaymentCheckAdd: BillPaymentCheckAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BillPaymentCheckAddRs {
  BillPaymentCheckRet?: BillPaymentCheckRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BillPaymentCheckMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. If a `BankAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  BankAccountRef?: BankAccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** `AppliedToTxn` List A list of `AppliedToTxn` aggregates. */
  AppliedToTxnMod?: AppliedToTxnMod | AppliedToTxnMod[];
}

export interface BillPaymentCheckModRq {
  BillPaymentCheckMod: BillPaymentCheckMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BillPaymentCheckModRs {
  BillPaymentCheckRet?: BillPaymentCheckRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BillPaymentCheckQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface BillPaymentCheckQueryRs {
  BillPaymentCheckRet: BillPaymentCheckRet[];
}

export interface BillPaymentCheckRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.) If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. If a `BankAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  BankAccountRef?: BankAccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Amount in units of the home currency. */
  AmountInHomeCurrency?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  AddressBlock?: AddressBlock;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** `AppliedToTxn` List A list of `AppliedToTxn` aggregates. */
  AppliedToTxnRet?: AppliedToTxnRet | AppliedToTxnRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface BillQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user.

  You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1.

  (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file.

  In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for.

  But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050.

  This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, or the account name exactly matches the account number. (In this case, query would return the correct account either way.)

  To avoid this problem:

  Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** Allows you to filter for transactions according to whether or not they are paid. */
  PaidStatus?: PaidStatus;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension: If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI. If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI.

  Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters.

  When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface BillQueryRs {
  BillRet: BillRet[];
}

export interface BillRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef: VendorRef;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.)

  If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** The date on which payment is due. */
  DueDate?: string;
  /** The total monetary amount shown on a bill or packing slip received from a vendor. `AmountDue` will be the total of the amounts in the expense lines, item lines, and item group lines. `AmountDue` minus any credits or discounts equals the `OpenAmount`. */
  AmountDue: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Amount due in units of the home currency. */
  AmountDueInHomeCurrency?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** If `IsPending` is set to true, the bill has not been completed or in draft version. `IsPending` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  IsPending?: boolean;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** Appears in the A/P register and in reports that include this bill. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** If `IsPaid` is true, this transaction has been paid. */
  IsPaid?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty.

  The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineRet?: ExpenseLineRet | ExpenseLineRet[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineRet?: ItemGroupLineRet | ItemGroupLineRet[];
  /** Indicates the amount that is still owed. `AmountDue` minus any credits or discounts equals the `OpenAmount`. */
  OpenAmount?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export type BudgetCriterion =
  | "Accounts"
  | "AccountsAndClasses"
  | "AccountsAndCustomers";

export interface BudgetSummaryReportQueryRq {
  /** The type of budget report being queried. */
  BudgetSummaryReportType: BudgetSummaryReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** Specify the fiscal year of the budget to be queried. There can only be one balance sheet budget for each fiscal year, one profit and loss (P&L) by account budget per fiscal year, and one profit and loss (P&L) by account and customer budget per fiscal year. When Fiscal year is not the current year, the report returns the data for the full fiscal year. When Fiscal year is the current year, the report only returns year to date data. */
  FiscalYear: number;
  /** What this budget covers. */
  BudgetCriterion?: BudgetCriterion;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** `SummarizeBudgetColumnsBy` determines which data the report calculates and how the columns will be labeled across the top of the report. */
  SummarizeBudgetColumnsBy?: SummarizeBudgetColumnsBy;
  /** How you want rows to be labeled in the report. For example, if you set the value to `sbrbAccount`, the report’s row labels might be “Checking,” “Savings,” and so on. */
  SummarizeBudgetRowsBy?: SummarizeBudgetRowsBy;
}

export interface BudgetSummaryReportQueryRs {
  ReportRet: ReportRet[];
}

export type BudgetSummaryReportType =
  | "BalanceSheetBudgetOverview"
  | "BalanceSheetBudgetVsActual"
  | "ProfitAndLossBudgetOverview"
  | "ProfitAndLossBudgetPerformance"
  | "ProfitAndLossBudgetVsActual";

export interface BuildAssemblyAdd {
  /** An inventory assembly item is one that is assembled or manufactured from inventory items. The items and/or assemblies that make up the assembly are called components. For Premier, an assembly can have a maximum of 100 components. For Enterprise, the maximum is 500 components. */
  ItemInventoryAssemblyRef: ItemInventoryAssemblyRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** Specifies the number of assemblies to be built. The transaction will fail if the number specified here exceeds the number of on-hand components. */
  QuantityToBuild: number;
  /** Allows the build assembly to be marked pending if there are insufficient quantities to complete the build assembly. */
  MarkPendingIfRequired?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface BuildAssemblyAddRq {
  BuildAssemblyAdd: BuildAssemblyAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BuildAssemblyAddRs {
  BuildAssemblyRet?: BuildAssemblyRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BuildAssemblyMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** Specifies the number of assemblies to be built. The transaction will fail if the number specified here exceeds the number of on-hand components. */
  QuantityToBuild?: number;
  /** Allows the build assembly to be marked pending if there are insufficient quantities to complete the build assembly. */
  MarkPendingIfRequired?: boolean;
  /** Changes the transaction’s pending status from Pending to non pending. In `BuildAssembly` transactions, this effectively does the build transaction. Hence, removing the Pending status will fail if there aren’t enough components on hand for the build. */
  RemovePending?: boolean;
}

export interface BuildAssemblyModRq {
  BuildAssemblyMod: BuildAssemblyMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface BuildAssemblyModRs {
  BuildAssemblyRet?: BuildAssemblyRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface BuildAssemblyQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks.Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1.(To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** Filters according to the item name or ID. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. */
  ItemFilter?: ItemFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Specifies whether the transaction is pending (posted) or not. */
  PendingStatus?: PendingStatus;
  /** Specify “true” if component line items for each returned transaction are to be included in the returned data. Specify “false” if the line items are not be returned. */
  IncludeComponentLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface BuildAssemblyQueryRs {
  BuildAssemblyRet: BuildAssemblyRet[];
}

export interface BuildAssemblyRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** An inventory assembly item is one that is assembled or manufactured from inventory items. The items and/or assemblies that make up the assembly are called components. For Premier, an assembly can have a maximum of 100 components. For Enterprise, the maximum is 500 components. */
  ItemInventoryAssemblyRef: ItemInventoryAssemblyRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** If `IsPending` is set to true, the transaction in question has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. Within QuickBooks, you can change the `IsPending` status for a credit memo, for example, by choosing “Mark Credit `Memo` As Pending” or “Mark Credit `Memo` As Final” from the Edit menu. */
  IsPending?: boolean;
  /** Specifies the number of assemblies to be built. The transaction will fail if the number specified here exceeds the number of on-hand components. */
  QuantityToBuild: number;
  /** Indicates the number of this assembly that can be built from the parts on hand. */
  QuantityCanBuild: number;
  /** The number of these items in inventory. `QuantityOnHand` times `AverageCost` is `TotalValue` in an inventory item list. To change the `QuantityOnHand` for an item, you would have to use `InventoryAdjustmentAdd` not an `ItemInventoryMod`. */
  QuantityOnHand: number;
  /** The number of these items that have been sold (as recorded in sales orders) but not delivered to customers. */
  QuantityOnSalesOrder: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** List of components in the assembly. */
  ComponentItemLineRet?: ComponentItemLineRet | ComponentItemLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export type CardSecurityCodeMatch = "Fail" | "NotAvailable" | "Pass";

export interface CashBackInfoAdd {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Additional information. */
  Memo?: string;
  /** A monetary amount. */
  Amount?: string;
}

export interface CashBackInfoMod {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Additional information. */
  Memo?: string;
  /** A monetary amount. */
  Amount?: string;
}

export interface CashBackInfoRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Additional information. */
  Memo?: string;
  /** A monetary amount. */
  Amount?: string;
}

export type CashFlowClassification =
  | "Financing"
  | "Investing"
  | "None"
  | "NotApplicable"
  | "Operating";

export interface ChargeAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Indicates the price of something. */
  Rate?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** A monetary amount. */
  Amount?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The date when the customer was billed for what is now being charged to their credit card. (`BilledDate` is the same as the date listed on an invoice or, for a statement charge, the date entered in the Statement `Date` field when the statement was printed.) */
  BilledDate?: string;
  /** The date on which payment is due. */
  DueDate?: string;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ChargeAddRq {
  ChargeAdd: ChargeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ChargeAddRs {
  ChargeRet?: ChargeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ChargeMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** Indicates the price of something. */
  Rate?: string;
  /** Flag to override price rule conflict */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** A monetary amount. */
  Amount?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The date when the customer was billed for what is now being charged to their credit card. (`BilledDate` is the same as the date listed on an invoice or, for a statement charge, the date entered in the Statement `Date` field when the statement was printed.) */
  BilledDate?: string;
  /** The date on which payment is due. */
  DueDate?: string;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
}

export interface ChargeModRq {
  ChargeMod: ChargeMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ChargeModRs {
  ChargeRet?: ChargeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ChargeQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Allows you to filter for transactions according to whether or not they are paid. */
  PaidStatus?: PaidStatus;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ChargeQueryRs {
  ChargeRet: ChargeRet[];
}

export interface ChargeRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** Indicates the price of something. */
  Rate?: string;
  /** A monetary amount. */
  Amount?: string;
  /** The outstanding balance on this invoice. `BalanceRemaining` = (`Subtotal` + `SalesTaxTotal`) – `AppliedAmount`. */
  BalanceRemaining?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The date when the customer was billed for what is now being charged to their credit card. (`BilledDate` is the same as the date listed on an invoice or, for a statement charge, the date entered in the Statement `Date` field when the statement was printed.) */
  BilledDate?: string;
  /** The date on which payment is due. */
  DueDate?: string;
  /** If `IsPaid` is true, this transaction has been paid. */
  IsPaid?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty. The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CheckAdd {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.)Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts?The following requests increase the balance in a bank account:Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account:`CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** The date written on the check. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** The memo that is printed on the check itself. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** Allows you to specify a transaction to be paid by this check. */
  ApplyCheckToTxnAdd?: ApplyCheckToTxnAdd | ApplyCheckToTxnAdd[];
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineAdd?: ExpenseLineAdd | ExpenseLineAdd[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineAdd?: ItemLineAdd | ItemLineAdd[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineAdd?: ItemGroupLineAdd | ItemGroupLineAdd[];
}

export interface CheckAddRq {
  CheckAdd: CheckAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CheckAddRs {
  CheckRet?: CheckRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CheckMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** The date written on the check. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** The memo that is printed on the check itself. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows you to specify a transaction to be paid by this check. */
  ApplyCheckToTxnMod?: ApplyCheckToTxnMod | ApplyCheckToTxnMod[];
  /** Set `ClearExpenseLines` to true to clear all the expense lines. To modify individual lines, use `ExpenseLineMod`. */
  ClearExpenseLines?: boolean;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineMod?: ExpenseLineMod | ExpenseLineMod[];
  /** Set `ClearItemLines` to true to clear all the item lines. To modify individual lines, use `ItemLineMod`. */
  ClearItemLines?: boolean;
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineMod?: ItemGroupLineMod | ItemGroupLineMod[];
}

export interface CheckModRq {
  CheckMod: CheckMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CheckModRs {
  CheckRet?: CheckRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CheckQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface CheckQueryRs {
  CheckRet: CheckRet[];
}

export interface CheckRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** The date written on the check. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** The total of the amounts in the expense lines, item lines, and item group lines. If a `CheckAdd` request does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate the `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  Amount: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Amount in units of the home currency. */
  AmountInHomeCurrency?: string;
  /** The memo that is printed on the check itself. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  AddressBlock?: AddressBlock;
  /** If `IsPending` is set to true, the check has not been completed or in draft version. `IsPending` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  IsPending?: boolean;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty. The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineRet?: ExpenseLineRet | ExpenseLineRet[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineRet?: ItemGroupLineRet | ItemGroupLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ClassAdd {
  /** The case-insensitive name of the class, not including the names of its ancestors. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
}

export interface ClassAddRq {
  ClassAdd: ClassAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ClassAddRs {
  ClassRet?: ClassRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ClassFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

export interface ClassMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of the class, not including the names of its ancestors. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
}

export interface ClassModRq {
  ClassMod: ClassMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ClassModRs {
  ClassRet?: ClassRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ClassQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ClassQueryRs {
  ClassRet: ClassRet[];
}

export interface ClassRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ClassRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of the class, not including the names of its ancestors. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
}

export interface COGSAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ColData {
  /** An identifying number that corresponds to the position of this column in the report. The columns are numbered from left to right, starting with 1. */
  ColID: number;
  /** The data in this cell of the report. */
  Value: string;
  /** The data type: IDTYPE, STRTYPE, and so on. */
  DataType: DataType;
}

export interface ColDesc {
  /** A list of `IColTitle` objects, each of which represents a title for this column. For example, if the first two rows of this column were titles, two `IColTitle` objects would be returned. */
  ColTitle: ColTitle | ColTitle[];
  /** The type of data that this column contains. `ColType` values are formatted types. (Returned `ctPercent` values, for example, will have digits after the decimal points, and ctAddr1 values will be strings.) */
  ColType: ColType;
  /** An identifying number that corresponds to the position of this column in the report. The columns are numbered from left to right, starting with 1. */
  ColID: number;
  /** The data type: IDTYPE, STRTYPE, and so on. */
  DataType: DataType;
}

export interface ColTitle {
  /** The number of this title row. For example, if the first three rows of a report were titles, `titleRow` of the third of these rows would be 3. */
  TitleRow: number;
  /** The data in this cell of the report. */
  Value: string;
}

export type ColType =
  | "Account"
  | "Addr1"
  | "Addr2"
  | "Addr3"
  | "Addr4"
  | "Addr5"
  | "Aging"
  | "Amount"
  | "AmountDifference"
  | "AverageCost"
  | "BilledDate"
  | "BillingStatus"
  | "Blank"
  | "CalculatedAmount"
  | "Class"
  | "ClearedStatus"
  | "CostPrice"
  | "CreateDate"
  | "Credit"
  | "CustomField"
  | "Date"
  | "Debit"
  | "DeliveryDate"
  | "DueDate"
  | "Duration"
  | "EarliestReceiptDate"
  | "EstimateActive"
  | "FOB"
  | "IncomeSubjectToTax"
  | "Invoiced"
  | "IsAdjustment"
  | "Item"
  | "ItemDesc"
  | "ItemVendor"
  | "Label"
  | "LastModifiedBy"
  | "LatestOrPriorState"
  | "Memo"
  | "ModifiedTime"
  | "Name"
  | "NameAccountNumber"
  | "NameAddress"
  | "NameCity"
  | "NameContact"
  | "NameEmail"
  | "NameFax"
  | "NamePhone"
  | "NameState"
  | "NameZip"
  | "OpenBalance"
  | "OriginalAmount"
  | "PaidAmount"
  | "PaidStatus"
  | "PaidThroughDate"
  | "PaymentMethod"
  | "PayrollItem"
  | "Percent"
  | "PercentChange"
  | "PercentOfTotalRetail"
  | "PercentOfTotalValue"
  | "PhysicalCount"
  | "PONumber"
  | "PrintStatus"
  | "ProgressAmount"
  | "ProgressPercent"
  | "Quantity"
  | "QuantityAvailable"
  | "QuantityOnHand"
  | "QuantityOnOrder"
  | "QuantityOnPendingBuild"
  | "QuantityOnSalesOrder"
  | "ReceivedQuantity"
  | "RefNumber"
  | "ReorderPoint"
  | "RetailValueOnHand"
  | "RunningBalance"
  | "SalesPerWeek"
  | "SalesRep"
  | "SalesTaxCode"
  | "ShipDate"
  | "ShipMethod"
  | "ShipToAddr1"
  | "ShipToAddr2"
  | "ShipToAddr3"
  | "ShipToAddr4"
  | "ShipToAddr5"
  | "SONumber"
  | "SourceName"
  | "SplitAccount"
  | "SSNOrTaxID"
  | "SuggestedReorder"
  | "TaxLine"
  | "TaxTableVersion"
  | "Terms"
  | "Total"
  | "TxnID"
  | "TxnNumber"
  | "TxnType"
  | "UnitPrice"
  | "UserEdit"
  | "ValueOnHand"
  | "WageBase"
  | "WageBaseTips";

export interface CompanyAddressBlockForCustomer {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface CompanyAddressForCustomer {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface CompanyQueryRq {
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface CompanyQueryRs {
  CompanyRet: CompanyRet[];
}

export interface CompanyRet {
  /** Indicates whether this company file is a QuickBooks “sample file.” */
  IsSampleCompany: boolean;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** `LegalCompanyName` and `LegalAddress` are used on a company’s tax forms and pay stubs. (`CompanyName` and `Address`, on the other hand, are used on invoices, checks, and other forms.) */
  LegalCompanyName?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  AddressBlock?: AddressBlock;
  /** `LegalAddress` and `LegalCompanyName` are used on a company’s tax forms and pay stubs. (Address and `CompanyName`, on the other hand, are used on invoices, checks, and other forms.) If an address request fails, some combination of address fields might be too long. */
  LegalAddress?: LegalAddress;
  /** The address where a QuickBooks company receives mail from its customers. If an address request fails, some combination of address fields might be too long. */
  CompanyAddressForCustomer?: CompanyAddressForCustomer;
  /** The company address for customers expressed as an address block of `Addr1` through `Addr5`. */
  CompanyAddressBlockForCustomer?: CompanyAddressBlockForCustomer;
  /** The telephone number. */
  Phone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** The company’s public Web address. */
  CompanyWebSite?: string;
  /** The first month in the 12-month period over which a company tracks its finances. The QuickBooks user sets this value. In QuickBooks, `FirstMonthFiscalYear` determines the default date range for some reports and graphs. */
  FirstMonthFiscalYear?: FirstMonthFiscalYear;
  /** In QuickBooks, `FirstMonthIncomeTaxYear` determines the default date range for income tax summary and detail reports. The QuickBooks user sets this value. */
  FirstMonthIncomeTaxYear?: FirstMonthIncomeTaxYear;
  /** The QuickBooks user selects a company type from a list when creating a company file. */
  CompanyType?: string;
  /** Employer Identification Number. */
  EIN?: string;
  /** Social security number. */
  SSN?: string;
  /** The tax form that the QuickBooks user expects to file for this company’s taxes. If a `TaxForm` value is assigned (that is, if it is not `OtherOrNone`), the QuickBooks user can associate each account with a tax form line. (An account’s tax form line information will show up in the response from an account query.) */
  TaxForm?: TaxForm;
  /** Information returned from a company query about the Intuit services that the company is currently subscribed to, for example, Intuit Payroll, QBMS, and so forth */
  SubscribedServices?: SubscribedServices;
  /** Aggregate containing information about accountant copy. An Accountant’s Copy is a version of your company file your accountant can use to make changes while the original company file continues to be used for most normal operations. The key part of the accountant copy “protocol” is the dividing date which defines the fiscal period within which the accountant will be working. Dividing date is key because there are enforced restrictions against certain types of operations on data that fall within the fiscal period the accountant is working on.continue to work. The restrictions are listed below: Transactions: You can work only on transactions dated after the dividing date. Accounts: You can add a new account, but you cannot add a new subaccount to an existing account. Existing accounts: You cannot edit, merge, or make an existing account inactive. New accounts: You can edit an account or make any account inactive that you created while your accountant has the Accountant’s Copy. Lists (other than Chart of Accounts): You can edit, sort, and make list items inactive. You cannot delete or merge list items. Reconciling:You can reconcile your accounts while your accountant has an Accountant’s Copy. All reconciliations that include transactions in the current period (after the dividing date) are saved and will not be undone.To prevent conflicts with your accountant’s changes, reconciliations that include transactions dated on or before the dividing date will be undone when you import your accountant’s changes. If your accountant has reconciled or undone a reconciliation for any period, any reconciliations you did will be undone when you import your accountant’s changes. */
  AccountantCopy?: AccountantCopy;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ComponentItemLineRet {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** The number of these items in inventory. `QuantityOnHand` times `AverageCost` is `TotalValue` in an inventory item list. To change the `QuantityOnHand` for an item, you would have to use `InventoryAdjustmentAdd` not an `ItemInventoryMod`. */
  QuantityOnHand?: number;
  /** Indicates the number of the component part that is required in the assembly. For example, if the `ItemRef` in this component is a bolt, the quantity needed field indicates how many of these bolts are used in the assembly. */
  QuantityNeeded?: number;
}

export interface Contacts {
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
}

export interface ContactsMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
}

export interface ContactsRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
}

export interface CreditCardChargeAdd {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the charge. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineAdd?: ExpenseLineAdd | ExpenseLineAdd[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineAdd?: ItemLineAdd | ItemLineAdd[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineAdd?: ItemGroupLineAdd | ItemGroupLineAdd[];
}

export interface CreditCardChargeAddRq {
  CreditCardChargeAdd: CreditCardChargeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CreditCardChargeAddRs {
  CreditCardChargeRet?: CreditCardChargeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CreditCardChargeMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.)

  Special cases to note:

  In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied. In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed.

  How do you increase and decrease amounts in bank accounts?

  The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd`

  The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written.

  In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the charge. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Set `ClearExpenseLines` to true to clear all the expense lines. To modify individual lines, use `ExpenseLineMod`. */
  ClearExpenseLines?: boolean;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineMod?: ExpenseLineMod | ExpenseLineMod[];
  /** Set `ClearItemLines` to true to clear all the item lines. To modify individual lines, use `ItemLineMod`. */
  ClearItemLines?: boolean;
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineMod?: ItemGroupLineMod | ItemGroupLineMod[];
}

export interface CreditCardChargeModRq {
  CreditCardChargeMod: CreditCardChargeMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CreditCardChargeModRs {
  CreditCardChargeRet?: CreditCardChargeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CreditCardChargeQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface CreditCardChargeQueryRs {
  CreditCardChargeRet: CreditCardChargeRet[];
}

export interface CreditCardChargeRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.)

  Special cases to note:

  In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied. In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed.

  How do you increase and decrease amounts in bank accounts?

  The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd`

  The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written.

  In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the charge. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** The total of the amounts in the expense lines, item lines, and item group lines. */
  Amount: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Amount in units of the home currency. */
  AmountInHomeCurrency?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineRet?: ExpenseLineRet | ExpenseLineRet[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineRet?: ItemGroupLineRet | ItemGroupLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CreditCardCreditAdd {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineAdd?: ExpenseLineAdd | ExpenseLineAdd[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineAdd?: ItemLineAdd | ItemLineAdd[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineAdd?: ItemGroupLineAdd | ItemGroupLineAdd[];
}

export interface CreditCardCreditAddRq {
  CreditCardCreditAdd: CreditCardCreditAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CreditCardCreditAddRs {
  CreditCardCreditRet?: CreditCardCreditRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CreditCardCreditMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Set `ClearExpenseLines` to true to clear all the expense lines. To modify individual lines, use `ExpenseLineMod`. */
  ClearExpenseLines?: boolean;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineMod?: ExpenseLineMod | ExpenseLineMod[];
  /** Set `ClearItemLines` to true to clear all the item lines. To modify individual lines, use `ItemLineMod`. */
  ClearItemLines?: boolean;
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineMod?: ItemGroupLineMod | ItemGroupLineMod[];
}

export interface CreditCardCreditModRq {
  CreditCardCreditMod: CreditCardCreditMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CreditCardCreditModRs {
  CreditCardCreditRet?: CreditCardCreditRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CreditCardCreditQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface CreditCardCreditQueryRs {
  CreditCardCreditRet: CreditCardCreditRet[];
}

export interface CreditCardCreditRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written. In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** The total of the amounts in the expense lines, item lines, and item group lines. */
  Amount: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Amount in units of the home currency. */
  AmountInHomeCurrency?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineRet?: ExpenseLineRet | ExpenseLineRet[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineRet?: ItemGroupLineRet | ItemGroupLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CreditCardInfo {
  /** Credit-card number for this customer or this payment. Beginning with qbXML spec 6.0 and QuickBooks 2007, you must mask the credit card number with lower case “x” and no dashes. For example, xxxxxxxxxxxx1234. */
  CreditCardNumber?: string;
  /** The month when the credit card expires. */
  ExpirationMonth?: number;
  /** The year when the credit card expires. */
  ExpirationYear?: number;
  /** The name on the customer’s credit card. */
  NameOnCard?: string;
  /** The address associated with this credit card. */
  CreditCardAddress?: string;
  /** The postal code associated with the address for this credit card. */
  CreditCardPostalCode?: string;
}

export interface CreditCardTxnInfo {
  /** This contains data originally supplied in the QBMS transaction request. This information block should not be used in `CreditMemo` requests for QuickBooks 2007 and new versions. Instead, use the `ARRefundCreditCard` request. */
  CreditCardTxnInputInfo: CreditCardTxnInputInfo;
  /** This contains data returned in the QBMS transaction response. This information block should not be used in `CreditMemo` requests for QuickBooks 2007 and new versions. Instead, use the `ARRefundCreditCard` request. */
  CreditCardTxnResultInfo: CreditCardTxnResultInfo;
}

export interface CreditCardTxnInfoMod {
  /** This contains data originally supplied in the QBMS transaction request. This information block should not be used in `CreditMemo` requests for QuickBooks 2007 and new versions. Instead, use the `ARRefundCreditCard` request. */
  CreditCardTxnInputInfoMod?: CreditCardTxnInputInfoMod;
  /** This contains data returned in the QBMS transaction response. This information block should not be used in `CreditMemo` requests for QuickBooks 2007 and new versions. Instead, use the `ARRefundCreditCard` request. */
  CreditCardTxnResultInfoMod?: CreditCardTxnResultInfoMod;
}

export interface CreditCardTxnInputInfo {
  /** Credit-card number for this customer or this payment. Beginning with qbXML spec 6.0 and QuickBooks 2007, you must mask the credit card number with lower case “x” and no dashes. For example, xxxxxxxxxxxx1234. */
  CreditCardNumber: string;
  /** The month when the credit card expires. */
  ExpirationMonth: number;
  /** The year when the credit card expires. */
  ExpirationYear: number;
  /** The name on the customer’s credit card. */
  NameOnCard: string;
  /** The address associated with this credit card. */
  CreditCardAddress?: string;
  /** The postal code associated with the address for this credit card. */
  CreditCardPostalCode?: string;
  /** This optional field is used only for Visa and Master Card commercial cards. There are three types of these cards: purchase, corporate, and business.

  Normally, special lower transaction fee rates apply when these cards are used and this field is filled out. If this field is left blank, then the usual (and higher) discount rate applies. */
  CommercialCardCode?: string;
  /** Indicates whether this transaction came from a card swipe (`tmCardPresent`) or not (`tmCardNotPresent`). */
  TransactionMode?: TransactionMode;
  /** Indicates the QBMS transaction from which the current transaction data originated, for example, Charge, Authorization, Capture, Refund, `VoiceAuthorization`, or Void. */
  CreditCardTxnType?: CreditCardTxnType;
}

export interface CreditCardTxnInputInfoMod {
  /** Credit-card number for this customer or this payment. Beginning with qbXML spec 6.0 and QuickBooks 2007, you must mask the credit card number with lower case “x” and no dashes. For example, xxxxxxxxxxxx1234. */
  CreditCardNumber?: string;
  /** The month when the credit card expires. */
  ExpirationMonth?: number;
  /** The year when the credit card expires. */
  ExpirationYear?: number;
  /** The name on the customer’s credit card. */
  NameOnCard?: string;
  /** The address associated with this credit card. */
  CreditCardAddress?: string;
  /** The postal code associated with the address for this credit card. */
  CreditCardPostalCode?: string;
  /** This optional field is used only for Visa and Master Card commercial cards. There are three types of these cards: purchase, corporate, and business.

  Normally, special lower transaction fee rates apply when these cards are used and this field is filled out. If this field is left blank, then the usual (and higher) discount rate applies. */
  CommercialCardCode?: string;
  /** Indicates whether this transaction came from a card swipe (`tmCardPresent`) or not (`tmCardNotPresent`). */
  TransactionMode?: TransactionMode;
  /** Indicates the QBMS transaction from which the current transaction data originated, for example, Charge, Authorization, Capture, Refund, `VoiceAuthorization`, or Void. */
  CreditCardTxnType?: CreditCardTxnType;
}

export interface CreditCardTxnResultInfo {
  /** This contains the status code returned in the original QBMS transaction response. */
  ResultCode: number;
  /** This contains the status message returned in the original QBMS transaction response. */
  ResultMessage: string;
  /** This transaction ID is returned from the credit card processor. You should save this value for any possible QBMS SDK transaction requests that need it, for example, `CustomerCreditCardTxnVoidRq`, or `CustomerCreditCardCaptureRq`.

  You should also save this transaction ID and include it in the QB SDK `SalesReceiptAdd` or `ReceivePaymentAdd` requests if you are intending to save the transaction data in QuickBooks. */
  CreditCardTransID: string;
  /** This is the QBMS account number of the merchant who is running the transaction using the customer’s credit card. It is returned from the transaction request and should be stored for subsequent transactions, such as using it in the QB SDK `SalesReceiptAdd`, `ReceivePaymentAdd`, `ARRefundCreditCard` requests to save the transaction data in QuickBooks. */
  MerchantAccountNumber: string;
  /** The authorization code is returned from the credit card processor to indicate that the charge will be paid by the card issuer.

  In a voice authorization request (`CustomerCreditCardVoiceAuthRq`), the authorization code is supplied by the card issuer over the telephone. */
  AuthorizationCode?: string;
  /** This field contains the value `avssPass` if the street address supplied in the transaction request matches the customer’s address on file at the card issuer. It contains the value `avssFail` if there is not a match, or `avssNotAvailable` if the card issuer does not support AVS.

  Note: This field was required in qbXML 4.1, but is optional in qbXML 5.0 and later. */
  AVSStreet?: AVSStreet;
  /** This field contains the value `avszPass` if the customer postal ZIP code supplied in the transaction request matches the customer’s postal code recognized at the card issuer. It contains the value `avszFail` if there is not a match, or `avszNotAvailable` if the card issuer does not support AVS.

  Note: This field was required in qbXML 4.1, but is optional in qbXML 5.0 and later. */
  AVSZip?: AVSZip;
  /** This field contains the value Pass if the card security code supplied in the transaction request matches the card security code recognized for that credit card number at the card issuer. It contains the value Fail if there is not a match. */
  CardSecurityCodeMatch?: CardSecurityCodeMatch;
  /** This value is returned by QBMS from the transaction request, and is used internally by the QuickBooks/QBMS Recon (reconcile) feature. You should save this value without modification and include it in the QB SDK `SalesReceiptAdd` or `ReceivePaymentAdd` requests if you want to save the transaction data in QuickBooks. */
  ReconBatchID?: string;
  /** Internal code needed for the QuickBooks reconciliation feature, if integrating with QuickBooks. This value is returned in the QBMS response to a QBMS transaction request, and must be subsequently supplied by your application in the QB SDK `ReceivePaymentAdd` or `SalesReceiptAdd` request. */
  PaymentGroupingCode?: number;
  /** Indicates whether the transaction is known to have been successfully processed by the card issuer, with the value “`psCompleted`” indicating success. That is, there was a response sent to QBMS and from QBMS to the application indicating success. The value “`psUnknown`” indicates that such a response was not received. If “Unknown” is returned, the transaction may have been successfully or unsuccessfully processed at the card issuer: there simply was no response (possibly due to network errors). */
  PaymentStatus: PaymentStatus;
  /** Timestamp indicating the time in which the card processor authorized the transaction. */
  TxnAuthorizationTime: string;
  /** This value is used to support the credit card transaction Reconcile feature within QuickBooks. */
  TxnAuthorizationStamp?: number;
  /** This value is returned from QBMS transactions for future use by the QuickBooks Reconciliation feature. */
  ClientTransID?: string;
}

export interface CreditCardTxnResultInfoMod {
  /** This contains the status code returned in the original QBMS transaction response. */
  ResultCode?: number;
  /** This contains the status message returned in the original QBMS transaction response. */
  ResultMessage?: string;
  /** This transaction ID is returned from the credit card processor. You should save this value for any possible QBMS SDK transaction requests that need it, for example, `CustomerCreditCardTxnVoidRq`, or `CustomerCreditCardCaptureRq`.

  You should also save this transaction ID and include it in the QB SDK `SalesReceiptAdd` or `ReceivePaymentAdd` requests if you are intending to save the transaction data in QuickBooks. */
  CreditCardTransID?: string;
  /** This is the QBMS account number of the merchant who is running the transaction using the customer’s credit card. It is returned from the transaction request and should be stored for subsequent transactions, such as using it in the QB SDK `SalesReceiptAdd`, `ReceivePaymentAdd`, `ARRefundCreditCard` requests to save the transaction data in QuickBooks. */
  MerchantAccountNumber?: string;
  /** The authorization code is returned from the credit card processor to indicate that the charge will be paid by the card issuer.

  In a voice authorization request (`CustomerCreditCardVoiceAuthRq`), the authorization code is supplied by the card issuer over the telephone. */
  AuthorizationCode?: string;
  /** This field contains the value `avssPass` if the street address supplied in the transaction request matches the customer’s address on file at the card issuer. It contains the value `avssFail` if there is not a match, or `avssNotAvailable` if the card issuer does not support AVS.

  Note: This field was required in qbXML 4.1, but is optional in qbXML 5.0 and later. */
  AVSStreet?: AVSStreet;
  /** This field contains the value `avszPass` if the customer postal ZIP code supplied in the transaction request matches the customer’s postal code recognized at the card issuer. It contains the value `avszFail` if there is not a match, or `avszNotAvailable` if the card issuer does not support AVS.

  Note: This field was required in qbXML 4.1, but is optional in qbXML 5.0 and later. */
  AVSZip?: AVSZip;
  /** This field contains the value Pass if the card security code supplied in the transaction request matches the card security code recognized for that credit card number at the card issuer. It contains the value Fail if there is not a match. */
  CardSecurityCodeMatch?: CardSecurityCodeMatch;
  /** This value is returned by QBMS from the transaction request, and is used internally by the QuickBooks/QBMS Recon (reconcile) feature. You should save this value without modification and include it in the QB SDK `SalesReceiptAdd` or `ReceivePaymentAdd` requests if you want to save the transaction data in QuickBooks. */
  ReconBatchID?: string;
  /** Internal code needed for the QuickBooks reconciliation feature, if integrating with QuickBooks. This value is returned in the QBMS response to a QBMS transaction request, and must be subsequently supplied by your application in the QB SDK `ReceivePaymentAdd` or `SalesReceiptAdd` request. */
  PaymentGroupingCode?: number;
  /** Indicates whether the transaction is known to have been successfully processed by the card issuer, with the value “`psCompleted`” indicating success. That is, there was a response sent to QBMS and from QBMS to the application indicating success. The value “`psUnknown`” indicates that such a response was not received. If “Unknown” is returned, the transaction may have been successfully or unsuccessfully processed at the card issuer: there simply was no response (possibly due to network errors). */
  PaymentStatus?: PaymentStatus;
  /** Timestamp indicating the time in which the card processor authorized the transaction. */
  TxnAuthorizationTime?: string;
  /** This value is used to support the credit card transaction Reconcile feature within QuickBooks. */
  TxnAuthorizationStamp?: number;
  /** This value is returned from QBMS transactions for future use by the QuickBooks Reconciliation feature. */
  ClientTransID?: string;
}

export type CreditCardTxnType =
  | "Authorization"
  | "Capture"
  | "Charge"
  | "Refund"
  | "VoiceAuthorization";

export interface CreditMemoAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsPending` is set to true, the credit memo has not been completed. Within QuickBooks, you can change the `IsPending` status for a credit memo by choosing “Mark Credit `Memo` As Pending” or “Mark Credit `Memo` As Final” from the Edit menu. */
  IsPending?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The memo does not print on the credit memo, but does appear in the account register and the customer register. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** Represents one line in the credit memo. Compare with `CreditMemoGroupLine`, which represents a previously defined group of lines in the credit memo. */
  CreditMemoLineAdd?: CreditMemoLineAdd | CreditMemoLineAdd[];
  /** Represents a previously defined group of lines in the credit memo. Compare with `CreditMemoLine`, which represents just one line in the credit memo. */
  CreditMemoLineGroupAdd?: CreditMemoLineGroupAdd | CreditMemoLineGroupAdd[];
}

export interface CreditMemoAddRq {
  CreditMemoAdd: CreditMemoAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CreditMemoAddRs {
  CreditMemoRet?: CreditMemoRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CreditMemoLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface CreditMemoLineGroupAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface CreditMemoLineGroupMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** Quantity For transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `ICreditMemoLineRet` objects, each representing one line in the credit memo. */
  CreditMemoLineMod?: CreditMemoLineMod | CreditMemoLineMod[];
}

export interface CreditMemoLineGroupRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup: boolean;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `ICreditMemoLineRet` objects, each representing one line in the credit memo. */
  CreditMemoLineRet?: CreditMemoLineRet | CreditMemoLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CreditMemoLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to.

  For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** Quantity For transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.)

  The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
}

export interface CreditMemoLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to.

  For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CreditMemoMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate:

  Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate:

  Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsPending` is set to true, the credit memo has not been completed. Within QuickBooks, you can change the `IsPending` status for a credit memo by choosing “Mark Credit `Memo` As Pending” or “Mark Credit `Memo` As Final” from the Edit menu. */
  IsPending?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The memo does not print on the credit memo, but does appear in the account register and the customer register. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once.

  Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch.

  Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Represents one line in the credit memo. Compare with `CreditMemoGroupLine`, which represents a previously defined group of lines in the credit memo. */
  CreditMemoLineMod?: CreditMemoLineMod;
  /** Represents a previously defined group of lines in the credit memo. Compare with `CreditMemoLine`, which represents just one line in the credit memo. */
  CreditMemoLineGroupMod?: CreditMemoLineGroupMod;
}

export interface CreditMemoModRq {
  CreditMemoMod: CreditMemoMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CreditMemoModRs {
  CreditMemoRet?: CreditMemoRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CreditMemoQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface CreditMemoQueryRs {
  CreditMemoRet: CreditMemoRet[];
}

export interface CreditMemoRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate:

  Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  BillAddressBlock?: BillAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate:

  Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** If `IsPending` is set to true, the credit memo has not been completed. Within QuickBooks, you can change the `IsPending` status for a credit memo by choosing “Mark Credit `Memo` As Pending” or “Mark Credit `Memo` As Final” from the Edit menu. */
  IsPending?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** The total of all the credit-memo lines, before taxes are applied. (By contrast, a subtotal item (an `ItemSubtotal` object) gives only the total of the amounts in the lines that appear above it.) */
  Subtotal?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The percentage charged for sales tax. */
  SalesTaxPercentage?: string;
  /** The total amount of sales tax charged. */
  SalesTaxTotal?: string;
  /** Subtotal plus `SalesTaxTotal`. */
  TotalAmount?: string;
  /** Available credit. */
  CreditRemaining?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** The amount of the remaining credit, expressed in units of the current home currency. */
  CreditRemainingInHomeCurrency?: string;
  /** The memo does not print on the credit memo, but does appear in the account register and the customer register. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once.

  Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch.

  Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty.

  The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** Represents one line in the credit memo. Compare with `CreditMemoGroupLine`, which represents a previously defined group of lines in the credit memo. */
  CreditMemoLineRet?: CreditMemoLineRet;
  /** Represents a previously defined group of lines in the credit memo. Compare with `CreditMemoLine`, which represents just one line in the credit memo. */
  CreditMemoLineGroupRet?: CreditMemoLineGroupRet;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CurrencyAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** For built-in currencies, the currency code and name is the generally accepted code and name. These are based on the standard ISO 4217 code/name for a country’s currency. In most cases, the currency code is composed of the country’s two-character Internet country code plus an extra character representing the currency unit. (Hence the code for Belize Dollars is simply Belize’ two-character Internet code (“BZ”) plus a one-character currency designator (“D”). For user defined currencies, if possible, this nomenclature could be followed but it is not required. */
  CurrencyCode: string;
  /** The aggregate controlling the appearance of the currency with regard to comma and decimal. */
  CurrencyFormat?: CurrencyFormat;
}

export interface CurrencyAddRq {
  CurrencyAdd: CurrencyAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CurrencyAddRs {
  CurrencyRet?: CurrencyRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CurrencyFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`.

  A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
}

export interface CurrencyFormat {
  /** This enumerated value controls how the thousandth’s place is separated from the next thousand, for example, 1,000,000. The default is Comma, as shown, but you can replace this with one of these values: Period, Space, Apostrophe . */
  ThousandSeparator?: ThousandSeparator;
  /** This enumerated value controls how the display of the currency value is grouped, for example, 10,000,000. The default is `XX_XXX_XXX` but you could replace this with `X_XX_XX_XXX` */
  ThousandSeparatorGrouping?: ThousandSeparatorGrouping;
  /** This enumerated value controls the display of the decimal value, for example, 1.00. The default is 2 which means 2 decimals are displayed to the right of the decimal point, but you can specify 0 (zero) if you don’t want’ decimals to be displayed. */
  DecimalPlaces?: DecimalPlaces;
  /** This enumerated value controls the display of the decimal point, for example, 1.00 or 1,00. The default is Period but you could alternatively specify a value of Comma. */
  DecimalSeparator?: DecimalSeparator;
}

export interface CurrencyMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** For built-in currencies, the currency code and name is the generally accepted code and name. These are based on the standard ISO 4217 code/name for a country’s currency. In most cases, the currency code is composed of the country’s two-character Internet country code plus an extra character representing the currency unit. (Hence the code for Belize Dollars is simply Belize’ two-character Internet code (“BZ”) plus a one-character currency designator (“D”). For user defined currencies, if possible, this nomenclature could be followed but it is not required. */
  CurrencyCode?: string;
  /** The aggregate controlling the appearance of the currency with regard to comma and decimal. */
  CurrencyFormat?: CurrencyFormat;
}

export interface CurrencyModRq {
  CurrencyMod: CurrencyMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CurrencyModRs {
  CurrencyRet?: CurrencyRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CurrencyQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CurrencyQueryRs {
  CurrencyRet: CurrencyRet[];
}

export interface CurrencyRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface CurrencyRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** For built-in currencies, the currency code and name is the generally accepted code and name. These are based on the standard ISO 4217 code/name for a country’s currency. In most cases, the currency code is composed of the country’s two-character Internet country code plus an extra character representing the currency unit. (Hence the code for Belize Dollars is simply Belize’ two-character Internet code (“BZ”) plus a one-character currency designator (“D”). For user defined currencies, if possible, this nomenclature could be followed but it is not required. */
  CurrencyCode?: string;
  /** The aggregate controlling the appearance of the currency with regard to comma and decimal. */
  CurrencyFormat?: CurrencyFormat;
  /** Indicates whether the currency is a built-in currency (value here would be false) or a currency created by a QuickBooks user (value here would be true). */
  IsUserDefinedCurrency?: boolean;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** The date when the exchange rate was last changed. */
  AsOfDate?: string;
}

export interface CustomDetailReportQueryRq {
  /** The type of report being queried. */
  CustomDetailReportType: CustomDetailReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Allows you to report on specific transaction types (for example, charge, check, deposit, or estimate). */
  ReportTxnTypeFilter?: ReportTxnTypeFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeRowsBy` (along with `IncludeColumnList`, in most cases) determines what data is calculated for this report and controls how the rows are organized and labeled. For example, if you set the value to `srbAccount`, the report’s row labels might be “Checking,” “Savings,” and so on. */
  SummarizeRowsBy: SummarizeRowsBy;
  /** A list of enum values showing which columns you want the report to return. (The report won’t return columns other than the ones you specify here.) */
  IncludeColumn: IncludeColumn | IncludeColumn[];
  /** Indicates whether this report should include all accounts or just those that are currently in use. */
  IncludeAccounts?: IncludeAccounts;
  /** The report will return open balance information up to the `ReportOpenBalanceAsOf` date. */
  ReportOpenBalanceAsOf?: ReportOpenBalanceAsOf;
  /** If `ReportBasis` is `rbCash`, the report bases income and expenses on the dates when money changed hands.`rbAccrual`, the report bases income on the dates when customers were invoiced and bases expenses on the dates when bills were entered.`rbNone`, the report uses the default `ReportBasis`, which is either the QuickBooks Preference setting or the QuickBooks default for a given type of report. In a report response, the SDK returns `rbNone` for reports that do not support `ReportBasis`. (The 1099 report, for example, has its own basis for generation.) */
  ReportBasis?: ReportBasis;
}

export interface CustomDetailReportQueryRs {
  ReportRet: ReportRet[];
}

export type CustomDetailReportType = "CustomTxnDetail";

export interface CustomerAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** List of ship to addresses. */
  ShipToAddress?: ShipToAddress | ShipToAddress[];
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Email address that would be carbon copied or CC. */
  Cc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** A list of contact records. */
  Contacts?: Contacts | Contacts[];
  /** Customer types allow business owners to categorize customers in ways that are meaningful for their businesses. For example, a customer type might indicate which industry a customer represents, or which part of the country a customer is in. A `CustomerTypeRef` aggregate refers to one of the types on the `CustomerType` list. In a request, if a `CustomerTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerTypeRef?: CustomerTypeRef;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** The opening balance of this customer’s account. A positive number indicates money owed by the customer. */
  OpenBalance?: string;
  /** The date of the opening balance for this customer. */
  OpenBalanceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Country that sales tax is collected for. */
  SalesTaxCountry?: SalesTaxCountry;
  /** The customer’s resale number, if they have one. This number will not affect reports or sales tax calculations. */
  ResaleNumber?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Set and returned as a positive number that indicates a customer’s or vendor’s credit limit. If no value has been defined, there is no credit limit. */
  CreditLimit?: string;
  /** Refers to a `PaymentMethod` object. In a request, if a `PreferredPaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PreferredPaymentMethodRef?: PreferredPaymentMethodRef;
  /** Customer’s credit-card information. */
  CreditCardInfo?: CreditCardInfo;
  /** `JobStatus` `Status` information about a sub-customer; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobStatus?: JobStatus;
  /** The date on which work for a sub-customer was started; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobStartDate?: string;
  /** The date on which work for a sub-customer is expected to be complete; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobProjectedEndDate?: string;
  /** The date on which work for a sub-customer was completed; used in reports.The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobEndDate?: string;
  /** A short job description for a sub-customer; used in reports.The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobDesc?: string;
  /** Job type can be used to separate jobs into any categories that are meaningful to the business. A `JobTypeRef` aggregate refers to a job type on the `JobType` list. In a request, if a `JobTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  JobTypeRef?: JobTypeRef;
  /** Not supported. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotes?: AdditionalNotes | AdditionalNotes[];
  /** Preference for how invoices are delivered. */
  PreferredDeliveryMethod?: PreferredDeliveryMethod;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** Tax registration number used in CA and UK. */
  TaxRegistrationNumber?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface CustomerAddRq {
  CustomerAdd: CustomerAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CustomerAddRs {
  CustomerRet?: CustomerRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CustomerMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** List of ship to addresses. */
  ShipToAddress?: ShipToAddress | ShipToAddress[];
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Email address that would be carbon copied or CC. */
  Cc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** A list of contact records. */
  ContactsMod?: ContactsMod | ContactsMod[];
  /** Customer types allow business owners to categorize customers in ways that are meaningful for their businesses. For example, a customer type might indicate which industry a customer represents, or which part of the country a customer is in. A `CustomerTypeRef` aggregate refers to one of the types on the `CustomerType` list. In a request, if a `CustomerTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerTypeRef?: CustomerTypeRef;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The country that sales tax is collected for. */
  SalesTaxCountry?: SalesTaxCountry;
  /** The customer’s resale number, if they have one. This number will not affect reports or sales tax calculations. */
  ResaleNumber?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Set and returned as a positive number that indicates a customer’s or vendor’s credit limit. If no value has been defined, there is no credit limit. */
  CreditLimit?: string;
  /** Refers to a `PaymentMethod` object. In a request, if a `PreferredPaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PreferredPaymentMethodRef?: PreferredPaymentMethodRef;
  /** Customer’s credit-card information. */
  CreditCardInfo?: CreditCardInfo;
  /** `JobStatus` `Status` information about a sub-customer; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobStatus?: JobStatus;
  /** The date on which work for a sub-customer was started; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobStartDate?: string;
  /** The date on which work for a sub-customer is expected to be complete; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobProjectedEndDate?: string;
  /** The date on which work for a sub-customer was completed; used in reports.The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobEndDate?: string;
  /** A short job description for a sub-customer; used in reports.The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobDesc?: string;
  /** Job type can be used to separate jobs into any categories that are meaningful to the business. A `JobTypeRef` aggregate refers to a job type on the `JobType` list. In a request, if a `JobTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  JobTypeRef?: JobTypeRef;
  /** Not supported. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotesMod?: AdditionalNotesMod | AdditionalNotesMod[];
  /** Preference for how invoices are delivered. */
  PreferredDeliveryMethod?: PreferredDeliveryMethod;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** The tax registration number used in CA and UK. */
  TaxRegistrationNumber?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface CustomerModRq {
  CustomerMod: CustomerMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CustomerModRs {
  CustomerRet?: CustomerRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CustomerMsgRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface CustomerQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to total balance. Total balance includes the balance for all subaccounts; for example, a customer’s `TotalBalance` would include all the jobs for that customer. */
  TotalBalanceFilter?: TotalBalanceFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** Filter according to class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface CustomerQueryRs {
  CustomerRet: CustomerRet[];
}

export interface CustomerRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface CustomerRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  BillAddressBlock?: BillAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** List of ship to addresses. */
  ShipToAddress?: ShipToAddress | ShipToAddress[];
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Email address that would be carbon copied or CC. */
  Cc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** A list of contact records. */
  ContactsRet?: ContactsRet | ContactsRet[];
  /** Customer types allow business owners to categorize customers in ways that are meaningful for their businesses. For example, a customer type might indicate which industry a customer represents, or which part of the country a customer is in. A `CustomerTypeRef` aggregate refers to one of the types on the `CustomerType` list. In a request, if a `CustomerTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerTypeRef?: CustomerTypeRef;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** A positive number indicates money owed by the customer. Compare with `TotalBalance`. */
  Balance?: string;
  /** Total balance for this customer, including all this customer’s jobs (subcustomers). A positive number indicates money that the customer owes. If a customer does not have any subcustomers, `TotalBalance` and `Balance` are the same. */
  TotalBalance?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The country that sales tax is collected for. */
  SalesTaxCountry?: SalesTaxCountry;
  /** The customer’s resale number, if they have one. This number will not affect reports or sales tax calculations. */
  ResaleNumber?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Set and returned as a positive number that indicates a customer’s or vendor’s credit limit. If no value has been defined, there is no credit limit. */
  CreditLimit?: string;
  /** Refers to a `PaymentMethod` object. In a request, if a `PreferredPaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PreferredPaymentMethodRef?: PreferredPaymentMethodRef;
  /** Customer’s credit-card information. */
  CreditCardInfo?: CreditCardInfo;
  /** `JobStatus` `Status` information about a sub-customer; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobStatus?: JobStatus;
  /** The date on which work for a sub-customer was started; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobStartDate?: string;
  /** The date on which work for a sub-customer is expected to be complete; used in reports. The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobProjectedEndDate?: string;
  /** The date on which work for a sub-customer was completed; used in reports.The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobEndDate?: string;
  /** A short job description for a sub-customer; used in reports.The Job- elements (`JobDesc`, `JobEndDate`, `JobProjectedEndDate`, `JobStartDate`, and `JobStatus`) correspond to the fields in the Job Info tab of the Edit Job window in QuickBooks. */
  JobDesc?: string;
  /** Job type can be used to separate jobs into any categories that are meaningful to the business. A `JobTypeRef` aggregate refers to a job type on the `JobType` list. In a request, if a `JobTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  JobTypeRef?: JobTypeRef;
  /** Not supported. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotesRet?: AdditionalNotesRet | AdditionalNotesRet[];
  /** Preference for how invoices are delivered. */
  PreferredDeliveryMethod?: PreferredDeliveryMethod;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** The tax registration number used in CA and UK. */
  TaxRegistrationNumber?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface CustomerSalesTaxCodeRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface CustomerTypeAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
}

export interface CustomerTypeAddRq {
  CustomerTypeAdd: CustomerTypeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CustomerTypeAddRs {
  CustomerTypeRet?: CustomerTypeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface CustomerTypeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface CustomerTypeQueryRs {
  CustomerTypeRet: CustomerTypeRet[];
}

export interface CustomerTypeRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface CustomerTypeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
}

export interface CustomSummaryReportQueryRq {
  /** The type of report being queried. */
  CustomSummaryReportType: CustomSummaryReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Allows you to report on specific transaction types (for example, charge, check, deposit, or estimate). */
  ReportTxnTypeFilter?: ReportTxnTypeFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeColumnsBy` determines which data the report calculates and how the columns will be labeled across the top of the report. For example, if you set the value to `scbTwoWeek`, the report’s column labels might be “Feb 10-23, 02,” “Feb 24-Mar9, 02,” and so on. */
  SummarizeColumnsBy: SummarizeColumnsBy;
  /** `SummarizeRowsBy` (along with `IncludeColumnList`, in most cases) determines what data is calculated for this report and controls how the rows are organized and labeled. For example, if you set the value to `srbAccount`, the report’s row labels might be “Checking,” “Savings,” and so on. */
  SummarizeRowsBy: SummarizeRowsBy;
  /** The default value is false, which means that the report will not include any subcolumn information. To include all available types of subcolumns for this report, set `IncludeSubcolumns` to true. The SDK will not return subcolumn information for data that can be easily computed. (For example, the SDK does not return the “percent of row” column.) */
  IncludeSubcolumns?: boolean;
  /** Specifies the type of year that will be used for this report. */
  ReportCalendar?: ReportCalendar;
  /** Specifies whether you want the report to include only rows with active information, only rows with nonzero values, or all rows regardless of their content or active status. */
  ReturnRows?: ReturnRows;
  /** Specifies whether you want the report to include only columns with active information, only columns with nonzero values, or all columns regardless of their content or active status. */
  ReturnColumns?: ReturnColumns;
  /** If `ReportBasis` is `rbCash`, the report bases income and expenses on the dates when money changed hands.`rbAccrual`, the report bases income on the dates when customers were invoiced and bases expenses on the dates when bills were entered.`rbNone`, the report uses the default `ReportBasis`, which is either the QuickBooks Preference setting or the QuickBooks default for a given type of report. In a report response, the SDK returns `rbNone` for reports that do not support `ReportBasis`. (The 1099 report, for example, has its own basis for generation.) */
  ReportBasis?: ReportBasis;
}

export interface CustomSummaryReportQueryRs {
  ReportRet: ReportRet[];
}

export type CustomSummaryReportType = "CustomSummary";

export interface DataExt {
  /** `OwnerID` refers to the owner of a data extension, and must be 0 or a valid GUID. (Custom fields, which are visible in the QuickBooks UI, always have an `OwnerID` of 0. )

  Usually you would keep your application’s GUID confidential to prevent other applications from accessing your data extensions. But if you want to share data extensions with another application, the applications need to use the same GUID. In this case, each application could use two GUIDs, one for shared data extensions and one for confidential data extensions. (An application can have any number of GUIDs.)

  When you share a data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID: string;
  /** The name of the data extension. If this is a custom field, `DataExtName` will be visible as a label in the QuickBooks user interface. Also because `OwnerID` and `DataExtName` together make the data extension unique, and because custom fields all have the same `OwnerID` of zero, the `DataExtName` must be a unique value among existing custom fields. In contrast, the `DataExtName` for private data extensions must be unique only for the specified `OwnerID` GUID. */
  DataExtName: string;
  /** The data in this field. The maximum length of `DataExtValue` will depend on the `DataExtType` of this data extension. For example, if `DataExtType` is `STR255TYPE`, the maximum length of `DataExtValue` is 255 characters. If `DataExtType` is `STR1024TYPE`, the maximum size of `DataExtValue` is `1KB`. */
  DataExtValue: string;
}

export interface DataExtRet {
  /** `OwnerID` refers to the owner of a data extension, and must be 0 or a valid GUID. (Custom fields, which are visible in the QuickBooks UI, always have an `OwnerID` of 0. )

  Usually you would keep your application’s GUID confidential to prevent other applications from accessing your data extensions. But if you want to share data extensions with another application, the applications need to use the same GUID. In this case, each application could use two GUIDs, one for shared data extensions and one for confidential data extensions. (An application can have any number of GUIDs.)

  When you share a data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string;
  /** The name of the data extension. If this is a custom field, `DataExtName` will be visible as a label in the QuickBooks user interface. Also because `OwnerID` and `DataExtName` together make the data extension unique, and because custom fields all have the same `OwnerID` of zero, the `DataExtName` must be a unique value among existing custom fields. In contrast, the `DataExtName` for private data extensions must be unique only for the specified `OwnerID` GUID. */
  DataExtName: string;
  /** The field’s data type, which corresponds to a qbXML data type. In an `IDataExtDefAdd` request object, if this is a custom field, `DataExtType` must be `detSTR255TYPE`. */
  DataExtType: DataExtType;
  /** The data in this field. The maximum length of `DataExtValue` will depend on the `DataExtType` of this data extension. For example, if `DataExtType` is `STR255TYPE`, the maximum length of `DataExtValue` is 255 characters. If `DataExtType` is `STR1024TYPE`, the maximum size of `DataExtValue` is `1KB`. */
  DataExtValue: string;
}

export type DataExtType =
  | "AMTTYPE"
  | "DATETIMETYPE"
  | "INTTYPE"
  | "PERCENTTYPE"
  | "PRICETYPE"
  | "QUANTYPE"
  | "STR255TYPE"
  | "STR1024TYPE";

export interface DataRow {
  /** `RowData` describes one row in the report. */
  RowData?: RowData;
  /** A list of `IColData` objects, each of which describes the data in one cell of the report. */
  ColData?: ColData | ColData[];
}

export type DataType =
  | "AMTTYPE"
  | "BOOLTYPE"
  | "DATETIMETYPE"
  | "DATETYPE"
  | "ENUMTYPE"
  | "GUIDTYPE"
  | "IDTYPE"
  | "INTTYPE"
  | "PERCENTTYPE"
  | "PRICETYPE"
  | "QUANTYPE"
  | "STRTYPE"
  | "TIMEINTERVALTYPE";

export interface DateDrivenTermsAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The day of the month when full payment is due with no discount. */
  DayOfMonthDue: number;
  /** Handles cases when an invoice or bill is issued close to its due date. If the invoice or bill is issued within this many days of the due date, payment is not due until the following month. For example, with a `DayOfMonthDue` of 15 and a `DueNextMonthDays` of 2, an invoice issued on May 13th would not be due until June 15th. */
  DueNextMonthDays?: number;
  /** If the payment is made by this day of the month, then `DiscountPct` applies. */
  DiscountDayOfMonth?: number;
  /** If payment is received by `DiscountDayOfMonth`, then this discount will apply to the payment. `DiscountPct` must be between 0 and 100. */
  DiscountPct?: string;
}

export interface DateDrivenTermsAddRq {
  DateDrivenTermsAdd: DateDrivenTermsAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface DateDrivenTermsAddRs {
  DateDrivenTermsRet?: DateDrivenTermsRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface DateDrivenTermsQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface DateDrivenTermsQueryRs {
  DateDrivenTermsRet: DateDrivenTermsRet[];
}

export interface DateDrivenTermsRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The day of the month when full payment is due with no discount. */
  DayOfMonthDue: number;
  /** Handles cases when an invoice or bill is issued close to its due date. If the invoice or bill is issued within this many days of the due date, payment is not due until the following month. For example, with a `DayOfMonthDue` of 15 and a `DueNextMonthDays` of 2, an invoice issued on May 13th would not be due until June 15th. */
  DueNextMonthDays?: number;
  /** If the payment is made by this day of the month, then `DiscountPct` applies. */
  DiscountDayOfMonth?: number;
  /** If payment is received by `DiscountDayOfMonth`, then this discount will apply to the payment. `DiscountPct` must be between 0 and 100. */
  DiscountPct?: string;
}

export type DateMacro =
  | "All"
  | "LastCalendarQuarter"
  | "LastCalendarQuarterToDate"
  | "LastCalendarYear"
  | "LastCalendarYearToDate"
  | "LastFiscalQuarter"
  | "LastFiscalQuarterToDate"
  | "LastFiscalYear"
  | "LastFiscalYearToDate"
  | "LastMonth"
  | "LastMonthToDate"
  | "LastWeek"
  | "LastWeekToDate"
  | "NextCalendarQuarter"
  | "NextCalendarYear"
  | "NextFiscalQuarter"
  | "NextFiscalYear"
  | "NextFourWeeks"
  | "NextMonth"
  | "NextWeek"
  | "ThisCalendarQuarter"
  | "ThisCalendarQuarterToDate"
  | "ThisCalendarYear"
  | "ThisCalendarYearToDate"
  | "ThisFiscalQuarter"
  | "ThisFiscalQuarterToDate"
  | "ThisFiscalYear"
  | "ThisFiscalYearToDate"
  | "ThisMonth"
  | "ThisMonthToDate"
  | "ThisWeek"
  | "ThisWeekToDate"
  | "Today"
  | "Yesterday";

/** @default: 2 */
export type DecimalPlaces = "0" | "2";

/** @default: Period */
export type DecimalSeparator = "Comma" | "Period";

export interface DepositAdd {
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef: DepositToAccountRef;
  /** Additional information. */
  Memo?: string;
  /** This aggregate is included if there is cash back from this deposit. `AccountRef` indicates where the cash back `Amount` is going (for example, into a petty cash account). */
  CashBackInfoAdd?: CashBackInfoAdd;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of deposit lines, each representing a deposit into the account referred to by `DepositToAccountRef`. Each deposit line is added as either a received payment (in an `IPaymentLine` object) or as a transfer from one account into another (in an `IDepositInfo` object). */
  DepositLineAdd?: DepositLineAdd | DepositLineAdd[];
}

export interface DepositAddRq {
  DepositAdd: DepositAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface DepositAddRs {
  DepositRet?: DepositRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface DepositLineAdd {
  /** For the `PaymentTxnID`, use either of these two values:A `TxnID` value exactly as it is returned by the `ReceivePaymentToDepositQuery` request, or A `TxnID` value exactly as it is returned in a `ReceivePaymentAdd` response. If you do not include a `PaymentTxnLineID` and include a `PaymentTxnID` for a transaction that includes payment lines, only the first payment line from that transaction will be deposited. */
  PaymentTxnID: string;
  /** For the `PaymentTxnLineID`, use a `TxnLineID` value exactly as it has been returned by the `ReceivePaymentToDepositQuery` request. If you do not include a `PaymentTxnLineID` and include a `PaymentTxnID` for a transaction that includes payment lines, only the first payment line from that transaction will be deposited. */
  PaymentTxnLineID?: string;
  /** Depost line memo additional information. */
  OverrideMemo?: string;
  /** Deposit line check number. */
  OverrideCheckNumber?: string;
  /** Deposit line class reference. */
  OverrideClassRef?: OverrideClassRef;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef?: EntityRef;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Additional information about this deposit line. */
  Memo?: string;
  /** The check number of a check that a QuickBooks user writes or receives from someone else. */
  CheckNumber?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
}

export interface DepositLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** For the `PaymentTxnID`, use either of these two values:A `TxnID` value exactly as it is returned by the `ReceivePaymentToDepositQuery` request, or A `TxnID` value exactly as it is returned in a `ReceivePaymentAdd` response. If you do not include a `PaymentTxnLineID` and include a `PaymentTxnID` for a transaction that includes payment lines, only the first payment line from that transaction will be deposited. */
  PaymentTxnID: string;
  /** For the `PaymentTxnLineID`, use a `TxnLineID` value exactly as it has been returned by the `ReceivePaymentToDepositQuery` request. If you do not include a `PaymentTxnLineID` and include a `PaymentTxnID` for a transaction that includes payment lines, only the first payment line from that transaction will be deposited. */
  PaymentTxnLineID?: string;
  /** Depost line memo additional information. */
  OverrideMemo?: string;
  /** Deposit line check number. */
  OverrideCheckNumber?: string;
  /** Deposit line class reference. */
  OverrideClassRef?: OverrideClassRef;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef?: EntityRef;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Additional information about this deposit line. */
  Memo?: string;
  /** The check number of a check that a QuickBooks user writes or receives from someone else. */
  CheckNumber?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
}

export interface DepositLineRet {
  /** The type of transaction. */
  TxnType?: TxnType;
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string;
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** For the `PaymentTxnLineID`, use a `TxnLineID` value exactly as it has been returned by the `ReceivePaymentToDepositQuery` request. If you do not include a `PaymentTxnLineID` and include a `PaymentTxnID` for a transaction that includes payment lines, only the first payment line from that transaction will be deposited. */
  PaymentTxnLineID?: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef?: EntityRef;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Additional information about this deposit line. */
  Memo?: string;
  /** The check number of a check that a QuickBooks user writes or receives from someone else. */
  CheckNumber?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
}

export interface DepositMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Additional information. */
  Memo?: string;
  /** This aggregate is included if there is cash back from this deposit. `AccountRef` indicates where the cash back `Amount` is going (for example, into a petty cash account). */
  CashBackInfoMod?: CashBackInfoMod;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** A list of deposit lines, each representing a deposit into the account referred to by `DepositToAccountRef`. Each deposit line is added as either a received payment (in an `IPaymentLine` object) or as a transfer from one account into another (in an `IDepositInfo` object). */
  DepositLineMod?: DepositLineMod | DepositLineMod[];
}

export interface DepositModRq {
  DepositMod: DepositMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface DepositModRs {
  DepositRet?: DepositRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface DepositQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface DepositQueryRs {
  DepositRet: DepositRet[];
}

export interface DepositRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef: DepositToAccountRef;
  /** Additional information. */
  Memo?: string;
  /** The sum of all the deposited amounts. */
  DepositTotal?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Amount of the deposit in units of the home currency. */
  DepositTotalInHomeCurrency?: string;
  /** This aggregate is included if there is cash back from this deposit. `AccountRef` indicates where the cash back `Amount` is going (for example, into a petty cash account). */
  CashBackInfoRet?: CashBackInfoRet;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of deposit lines, each representing a deposit into the account referred to by `DepositToAccountRef`. Each deposit line is added as either a received payment (in an `IPaymentLine` object) or as a transfer from one account into another (in an `IDepositInfo` object). */
  DepositLineRet?: DepositLineRet | DepositLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface DepositToAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type Disabled = "No" | "Yes";

export interface DiscountAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface DiscountClassRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface Earnings {
  /** Each payroll wage item describes and names a payment scheme, for example, Regular Pay or Overtime Pay. A `PayrollItemWageRef` aggregate refers to one of these wage items. In a request, if a `PayrollItemWageRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Within QuickBooks, a timesheet can specify a payroll wage item only if the following criteria are met: The name on the timesheet (which corresponds to the `EntityRef` in the `TimeTracking` object) is on the QuickBooks Employee list, and The “Use time data to create paychecks” preference is turned on in the QuickBooks Payroll Info window that provides detailed employee information employee. */
  PayrollItemWageRef: PayrollItemWageRef;
  /** Indicates the price of something. */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
}

export interface EmergencyContacts {
  /** Primary emergency contact information for the employee. */
  PrimaryContact?: PrimaryContact;
  /** Secondary emergency contact information for the employee. */
  SecondaryContact?: SecondaryContact;
}

export interface EmployeeAdd {
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** The name of a customer, vendor, employee, or person on the “other names” list in the employment job details section. */
  SupervisorRef?: SupervisorRef;
  /** The name of the department in the employment job details section. */
  Department?: string;
  /** The description details in the employment job details section. */
  Description?: string;
  /** The target bonus amount in the employment job details section. */
  TargetBonus?: string;
  /** If an address request fails, some combination of address fields might be too long. If you use payroll, you must specify the employee’s city, state (or province), ZIP (or postal) code, and at least one line of the street address. (Note that the `State` element has restrictions when it’s used in the `EmployeeAddress` aggregate. For more information, click `State` in the table.) */
  EmployeeAddress?: EmployeeAddress;
  /** By default within QuickBooks, the `PrintAs` element is the same as the `Name` element. */
  PrintAs?: string;
  /** The telephone number. */
  Phone?: string;
  /** Mobile telephone number. */
  Mobile?: string;
  /** The pager number. */
  Pager?: string;
  /** A personal identification number for this employee’s pager. */
  PagerPIN?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** Social security number. When you add an `SSN` value to an employee record, it does not have to include dashes; for example, either 123-45-6789 or 123456789 would be valid. */
  SSN?: string;
  /** E-mail address. */
  Email?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** Emergency `Contact` information for the employee. */
  EmergencyContacts?: EmergencyContacts;
  /** `EmployeeType` can affect payroll taxes for an employee. A statutory employee is a person who is defined as an employee by statute. Usually an owner or partner will be on the `Other` Names list, but if they are on the Employee list, their `EmployeeType` will be Owner. */
  EmployeeType?: EmployeeType;
  /** Full or Part time status of the employee. */
  PartOrFullTime?: PartOrFullTime;
  /** Exempt or Non-exempt status of the employee. */
  Exempt?: Exempt;
  /** Is employee a key or critical employee. */
  KeyEmployee?: KeyEmployee;
  /** The gender of this employee. */
  Gender?: Gender;
  /** An employee’s date of hire. */
  HiredDate?: string;
  /** Original hire date the employee was hired. */
  OriginalHireDate?: string;
  /** Adjusted service date for the employee. */
  AdjustedServiceDate?: string;
  /** The date on which this person’s employment with the company ended. */
  ReleasedDate?: string;
  /** Date of birth. */
  BirthDate?: string;
  /** Is employee a US citizen? */
  USCitizen?: USCitizen;
  /** Ethnicity of employee from `AmericianIndian`, Asian, Black, Hawaiian, Hispanic, White, `TwoOrMoreRaces` */
  Ethnicity?: Ethnicity;
  /** Is employee disabled? */
  Disabled?: Disabled;
  /** Description of employee’s disablitily. */
  DisabilityDesc?: string;
  /** Is the employee’s I-9 on file? */
  OnFile?: OnFile;
  /** Date the employee’s work authorization expires. */
  WorkAuthExpireDate?: string;
  /** Is employee a US veteran? */
  USVeteran?: USVeteran;
  /** Military status if the employee is a US veteran. */
  MilitaryStatus?: MilitaryStatus;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotes?: AdditionalNotes | AdditionalNotes[];
  /** Billing rates are used to override the service item rate in a time transaction (`TimeTrackingAdd`) based on the employee or vendor performing the work. Billing rates are assigned to an employee or a vendor to specify overrides to service items. */
  BillingRateRef?: BillingRateRef;
  /** Pay information for this employee. */
  EmployeePayrollInfo?: EmployeePayrollInfo;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface EmployeeAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The city name in an address. */
  City?: string;
  /** When it appears in the `EmployeeAddress` aggregate, the `State` element acts like an ENUMTYPE with the following possible values: None, AA (military), AE (military), AK, AL, AP (military), AR, AZ, CA, CO, CT, DC, DE, FL, GA, HI, IA, ID, IL, IN, KS, KY, LA, MA, MD, ME, MI, MN, MO, MS, MT, NC, ND, NE, NH, NJ, NM, NV, NY, OH, OK, OR, PA, PR, RI, SC, SD, TN, TX, UT, VA, VT, WA, WI, WV, and WY. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
}

export interface EmployeeAddRq {
  EmployeeAdd: EmployeeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface EmployeeAddRs {
  EmployeeRet?: EmployeeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface EmployeeMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** The name of a customer, vendor, employee, or person on the “other names” list in the employment job details section. */
  SupervisorRef?: SupervisorRef;
  /** The name of the department in the employment job details section. */
  Department?: string;
  /** The description details in the employment job details section. */
  Description?: string;
  /** The target bonus amount in the employment job details section. */
  TargetBonus?: string;
  /** If an address request fails, some combination of address fields might be too long. If you use payroll, you must specify the employee’s city, state (or province), ZIP (or postal) code, and at least one line of the street address. (Note that the `State` element has restrictions when it’s used in the `EmployeeAddress` aggregate. For more information, click `State` in the table.) */
  EmployeeAddress?: EmployeeAddress;
  /** By default within QuickBooks, the `PrintAs` element is the same as the `Name` element. */
  PrintAs?: string;
  /** The telephone number. */
  Phone?: string;
  /** Mobile telephone number. */
  Mobile?: string;
  /** The pager number. */
  Pager?: string;
  /** A personal identification number for this employee’s pager. */
  PagerPIN?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** Emergency `Contact` information for the employee. */
  EmergencyContacts?: EmergencyContacts;
  /** `EmployeeType` can affect payroll taxes for an employee. A statutory employee is a person who is defined as an employee by statute. Usually an owner or partner will be on the `Other` Names list, but if they are on the Employee list, their `EmployeeType` will be Owner. */
  EmployeeType?: EmployeeType;
  /** Full or Part time status of the employee. */
  PartOrFullTime?: PartOrFullTime;
  /** Exempt or Non-exempt status of the employee. */
  Exempt?: Exempt;
  /** Is employee a key or critical employee. */
  KeyEmployee?: KeyEmployee;
  /** An employee’s date of hire. */
  HiredDate?: string;
  /** Original hire date the employee was hired. */
  OriginalHireDate?: string;
  /** Adjusted service date for the employee. */
  AdjustedServiceDate?: string;
  /** The date on which this person’s employment with the company ended. */
  ReleasedDate?: string;
  /** Date of birth. */
  BirthDate?: string;
  /** Is employee a US citizen? */
  USCitizen?: USCitizen;
  /** Ethnicity of employee from `AmericianIndian`, Asian, Black, Hawaiian, Hispanic, White, `TwoOrMoreRaces`. */
  Ethnicity?: Ethnicity;
  /** Is employee disabled? */
  Disabled?: Disabled;
  /** Description of employee’s disablitily. */
  DisabilityDesc?: string;
  /** Is the employee’s I-9 on file? */
  OnFile?: OnFile;
  /** Date the employee’s work authorization expires. */
  WorkAuthExpireDate?: string;
  /** Is employee a US veteran? */
  USVeteran?: USVeteran;
  /** Military status if the employee is a US veteran. */
  MilitaryStatus?: MilitaryStatus;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotesMod?: AdditionalNotesMod | AdditionalNotesMod[];
  /** Billing rates are used to override the service item rate in a time transaction (`TimeTrackingAdd`) based on the employee or vendor performing the work. Billing rates are assigned to an employee or a vendor to specify overrides to service items. */
  BillingRateRef?: BillingRateRef;
  /** Pay information for this employee. */
  EmployeePayrollInfoMod?: EmployeePayrollInfoMod;
}

export interface EmployeeModRq {
  EmployeeMod: EmployeeMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface EmployeeModRs {
  EmployeeRet?: EmployeeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface EmployeePayrollInfo {
  /** Indicates how often employees are paid. If you include a blank `PayPeriod` element in an `EmployeeMod` message, you’ll receive an error. The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  PayPeriod?: PayPeriod;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** If `ClearEarnings` is set to true, the earnings will be deleted for this employee. */
  ClearEarnings?: boolean;
  /** A list of `IEarnings` aggregate objects. If an `EmployeeMod` request does not include any `IEarnings` objects, the earnings table for that employee will not change. If `EmployeeMod` includes at least one `IEarnings` object, all existing earnings information will be deleted for that employee, and all the earnings information in the -Mod request will be added. (To delete all the earnings information, set the `ClearEarnings` field to true in an `EmployeeMod` request.) */
  Earnings?: Earnings | Earnings[];
  /** Indicates whether or not paychecks are generated from time-tracking data. If you include a blank `IsUsingTimeDataToCreatePaychecks` element in an `EmployeeMod` message, you’ll receive an error. */
  IsUsingTimeDataToCreatePaychecks?: boolean;
  /** Indicates whether time data is used to create paychecks for this employee. */
  UseTimeDataToCreatePaychecks?: UseTimeDataToCreatePaychecks;
  /** Describes how “sick time” is accrued for this employee, along with how many sick hours the employee has accrued. */
  SickHours?: SickHours;
  /** Describes how vacation time is accrued for this employee, along with how many vacation hours the employee has accrued. */
  VacationHours?: VacationHours;
}

export interface EmployeePayrollInfoMod {
  /** Indicates how often employees are paid. If you include a blank `PayPeriod` element in an `EmployeeMod` message, you’ll receive an error. The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  PayPeriod?: PayPeriod;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** If `ClearEarnings` is set to true, the earnings will be deleted for this employee. */
  ClearEarnings?: boolean;
  /** A list of `IEarnings` aggregate objects. If an `EmployeeMod` request does not include any `IEarnings` objects, the earnings table for that employee will not change. If `EmployeeMod` includes at least one `IEarnings` object, all existing earnings information will be deleted for that employee, and all the earnings information in the -Mod request will be added. (To delete all the earnings information, set the `ClearEarnings` field to true in an `EmployeeMod` request.) */
  Earnings?: Earnings | Earnings[];
  /** Indicates whether or not paychecks are generated from time-tracking data. If you include a blank `IsUsingTimeDataToCreatePaychecks` element in an `EmployeeMod` message, you’ll receive an error. */
  IsUsingTimeDataToCreatePaychecks?: boolean;
  /** Indicates whether time data is used to create paychecks for this employee. */
  UseTimeDataToCreatePaychecks?: UseTimeDataToCreatePaychecks;
  /** Describes how “sick time” is accrued for this employee, along with how many sick hours the employee has accrued. */
  SickHours?: SickHours;
  /** Describes how vacation time is accrued for this employee, along with how many vacation hours the employee has accrued. */
  VacationHours?: VacationHours;
}

export interface EmployeeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface EmployeeQueryRs {
  EmployeeRet: EmployeeRet[];
}

export interface EmployeeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** A concatenation of `FirstName`, `MiddleName`, and `LastName`. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** The name of a customer, vendor, employee, or person on the “other names” list in the employment job details section. */
  SupervisorRef?: SupervisorRef;
  /** The name of the department in the employment job details section. */
  Department?: string;
  /** The description details in the employment job details section. */
  Description?: string;
  /** The target bonus amount in the employment job details section. */
  TargetBonus?: string;
  /** If an address request fails, some combination of address fields might be too long. If you use payroll, you must specify the employee’s city, state (or province), ZIP (or postal) code, and at least one line of the street address. (Note that the `State` element has restrictions when it’s used in the `EmployeeAddress` aggregate. For more information, click `State` in the table.) */
  EmployeeAddress?: EmployeeAddress;
  /** By default within QuickBooks, the `PrintAs` element is the same as the `Name` element. */
  PrintAs?: string;
  /** The telephone number. */
  Phone?: string;
  /** Mobile telephone number. */
  Mobile?: string;
  /** The pager number. */
  Pager?: string;
  /** A personal identification number for this employee’s pager. */
  PagerPIN?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** Social security number. When you add an `SSN` value to an employee record, it does not have to include dashes; for example, either 123-45-6789 or 123456789 would be valid. */
  SSN?: string;
  /** E-mail address. */
  Email?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** Emergency `Contact` information for the employee. */
  EmergencyContacts?: EmergencyContacts;
  /** `EmployeeType` can affect payroll taxes for an employee. A statutory employee is a person who is defined as an employee by statute. Usually an owner or partner will be on the `Other` Names list, but if they are on the Employee list, their `EmployeeType` will be Owner. */
  EmployeeType?: EmployeeType;
  /** Full or Part time status of the employee. */
  PartOrFullTime?: PartOrFullTime;
  /** Exempt or Non-exempt status of the employee. */
  Exempt?: Exempt;
  /** Is employee a key or critical employee. */
  KeyEmployee?: KeyEmployee;
  /** The gender of this employee. */
  Gender?: Gender;
  /** An employee’s date of hire. */
  HiredDate?: string;
  /** Original hire date the employee was hired. */
  OriginalHireDate?: string;
  /** Adjusted service date for the employee. */
  AdjustedServiceDate?: string;
  /** The date on which this person’s employment with the company ended. */
  ReleasedDate?: string;
  /** Date of birth. */
  BirthDate?: string;
  /** Is employee a US citizen? */
  USCitizen?: USCitizen;
  /** Ethnicity of employee from `AmericianIndian`, Asian, Black, Hawaiian, Hispanic, White, `TwoOrMoreRaces`. */
  Ethnicity?: Ethnicity;
  /** Is employee disabled? */
  Disabled?: Disabled;
  /** Description of employee’s disablitily. */
  DisabilityDesc?: string;
  /** Is the employee’s I-9 on file? */
  OnFile?: OnFile;
  /** Date the employee’s work authorization expires. */
  WorkAuthExpireDate?: string;
  /** Is employee a US veteran? */
  USVeteran?: USVeteran;
  /** Military status if the employee is a US veteran. */
  MilitaryStatus?: MilitaryStatus;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotesRet?: AdditionalNotesRet | AdditionalNotesRet[];
  /** Billing rates are used to override the service item rate in a time transaction (`TimeTrackingAdd`) based on the employee or vendor performing the work. Billing rates are assigned to an employee or a vendor to specify overrides to service items. */
  BillingRateRef?: BillingRateRef;
  /** Pay information for this employee. */
  EmployeePayrollInfo?: EmployeePayrollInfo;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

/** @default: Regular */
export type EmployeeType = "Officer" | "Owner" | "Regular" | "Statutory";

export interface EntityFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`.

  A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

export interface EntityRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type EntityTypeFilter = "Customer" | "Employee" | "OtherName" | "Vendor";

export interface ErrorRecovery {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** Refers to the owner of a data extension:

  If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI. If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI.

  Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters.

  When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string;
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface EstimateAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Message that appears in reports, but not on the estimate. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** One line of this estimate. Compare with `EstimateLineGroup`, which represents a previously defined group of lines in the estimate. In a Mod request, you can add a new line by supplying a `TxnLineID` value of -1. */
  EstimateLineAdd?: EstimateLineAdd | EstimateLineAdd[];
  /** Represents a previously defined group of lines in the estimate. Compare with `EstimateLine`, which represents just one line in the estimate. */
  EstimateLineGroupAdd?: EstimateLineGroupAdd | EstimateLineGroupAdd[];
}

export interface EstimateAddRq {
  EstimateAdd: EstimateAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface EstimateAddRs {
  EstimateRet?: EstimateRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface EstimateLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The markup that will be passed on to the customer for this item on this estimate. Amount, quantity, rate, and markup are related in the following way: `Amount` = (`Quantity` * `Rate`) + amount of markup */
  MarkupRate?: string;
  /** The markup (expressed as a percentage) that will be passed on to the customer for this item on this estimate. Amount, quantity, rate, and markup are related in the following way: `Amount` = (`Quantity` * `Rate`) + amount of markup */
  MarkupRatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface EstimateLineGroupAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface EstimateLineGroupMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** Quantity For transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `IOREstimateLineMod` objects, each representing one line in the estimate. Notice that each `IOREstimateLineMod` object contains a `TxnLineID` which must either be a `TxnLineID` from an existing line, or -1 if you are adding a new line to the existing estimate. */
  EstimateLineMod?: EstimateLineMod | EstimateLineMod[];
}

export interface EstimateLineGroupRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup: boolean;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `IOREstimateLineMod` objects, each representing one line in the estimate. Notice that each `IOREstimateLineMod` object contains a `TxnLineID` which must either be a `TxnLineID` from an existing line, or -1 if you are adding a new line to the existing estimate. */
  EstimateLineRet?: EstimateLineRet | EstimateLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface EstimateLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items.

  Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** Quantity For transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The markup that will be passed on to the customer for this item on this estimate. Amount, quantity, rate, and markup are related in the following way:

  Amount = (`Quantity` * `Rate`) + amount of markup */
  MarkupRate?: string;
  /** The markup (expressed as a percentage) that will be passed on to the customer for this item on this estimate. Amount, quantity, rate, and markup are related in the following way:

  Amount = (`Quantity` * `Rate`) + amount of markup */
  MarkupRatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.)

  The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders.

  Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
}

export interface EstimateLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items.

  Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The markup that will be passed on to the customer for this item on this estimate. Amount, quantity, rate, and markup are related in the following way:

  Amount = (`Quantity` * `Rate`) + amount of markup */
  MarkupRate?: string;
  /** The markup (expressed as a percentage) that will be passed on to the customer for this item on this estimate. Amount, quantity, rate, and markup are related in the following way:

  Amount = (`Quantity` * `Rate`) + amount of markup */
  MarkupRatePercent?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface EstimateMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** If `CreateChangeOrder` is true, the modifications are tracked as a “change order” that appears in the description field at the bottom of the estimate form in QuickBooks. A change order specifies exactly what changed, the dollar amount of each change, and the net dollar change to the estimate. */
  CreateChangeOrder?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward.

  When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate.

  One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Message that appears in reports, but not on the estimate. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch.

  Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** One line of this estimate. Compare with `EstimateLineGroup`, which represents a previously defined group of lines in the estimate.

  In a Mod request, you can add a new line by supplying a `TxnLineID` value of -1. */
  EstimateLineMod?: EstimateLineMod;
  /** Represents a previously defined group of lines in the estimate. Compare with `EstimateLine`, which represents just one line in the estimate. */
  EstimateLineGroupMod?: EstimateLineGroupMod;
}

export interface EstimateModRq {
  EstimateMod: EstimateMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface EstimateModRs {
  EstimateRet?: EstimateRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface EstimateQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface EstimateQueryRs {
  EstimateRet: EstimateRet[];
}

export interface EstimateRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  BillAddressBlock?: BillAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The total of all the estimate lines before taxes are applied. (By contrast, a subtotal item (an `ItemSubtotal` object) gives only the total of the amounts in the lines that appear above it.) */
  Subtotal?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward.

  When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate.

  One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The percentage charged for sales tax. */
  SalesTaxPercentage?: string;
  /** The total amount of sales tax charged. */
  SalesTaxTotal?: string;
  /** Subtotal plus `SalesTaxTotal`. */
  TotalAmount?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Total amount of money paid or received in the home currency. */
  TotalAmountInHomeCurrency?: string;
  /** Message that appears in reports, but not on the estimate. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch.

  Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty.

  The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** One line of this estimate. Compare with `EstimateLineGroup`, which represents a previously defined group of lines in the estimate.

  In a Mod request, you can add a new line by supplying a `TxnLineID` value of -1. */
  EstimateLineRet?: EstimateLineRet;
  /** Represents a previously defined group of lines in the estimate. Compare with `EstimateLine`, which represents just one line in the estimate. */
  EstimateLineGroupRet?: EstimateLineGroupRet;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export type Ethnicity =
  | "AmericianIndian"
  | "Asian"
  | "Black"
  | "Hawaiian"
  | "Hispanic"
  | "TwoOrMoreRaces"
  | "White";

export type Exempt = "Exempt" | "NonExempt";

export interface ExpenseAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ExpenseLineAdd {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.)

  Special cases to note:

  In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied. In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed.

  How do you increase and decrease amounts in bank accounts?

  The following requests increase the balance in a bank account:

  Deposit Add

  `ReceivePaymentAdd`

  Journal Entry Add

  Sales `ReceiptAdd` The following requests decrease the balance in a bank account:

  `CheckAdd`

  Bill `PaymentCheckAdd`

  `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information about this expense line. */
  Memo?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface ExpenseLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.)

  Special cases to note: In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied. In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed.

  How do you increase and decrease amounts in bank accounts?

  The following requests increase the balance in a bank account:

  Deposit Add

  `ReceivePaymentAdd`

  Journal Entry Add

  Sales `ReceiptAdd`

  The following requests decrease the balance in a bank account:

  `CheckAdd`

  Bill `PaymentCheckAdd`

  `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information about this expense line. */
  Memo?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:

  In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
}

export interface ExpenseLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.)

  Special cases to note:

  In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied. In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed.

  How do you increase and decrease amounts in bank accounts?

  The following requests increase the balance in a bank account:

  Deposit Add

  `ReceivePaymentAdd`

  Journal Entry Add

  Sales `ReceiptAdd` The following requests decrease the balance in a bank account:

  `CheckAdd`

  Bill `PaymentCheckAdd`

  `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information about this expense line. */
  Memo?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:

  In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export type FirstMonthFiscalYear =
  | "April"
  | "August"
  | "December"
  | "February"
  | "January"
  | "July"
  | "June"
  | "March"
  | "May"
  | "November"
  | "October"
  | "September";

export type FirstMonthIncomeTaxYear =
  | "April"
  | "August"
  | "December"
  | "February"
  | "January"
  | "July"
  | "June"
  | "March"
  | "May"
  | "November"
  | "October"
  | "September";

export interface FixedAssetSalesInfo {
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc: string;
  /** Date when a fixed asset was sold. */
  SalesDate: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Any expenses that were incurred during the sale of a fixed asset. */
  SalesExpense?: string;
}

export interface FixedAssetSalesInfoMod {
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Date when a fixed asset was sold. */
  SalesDate?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Any expenses that were incurred during the sale of a fixed asset. */
  SalesExpense?: string;
}

export interface FromInventorySiteLocationRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface FromInventorySiteRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type Gender = "Female" | "Male";

export interface GeneralDetailReportQueryRq {
  /** The type of general detail report to return. (If you specify `gdrtMissingChecks`, you must also specify an account type in the account filter.) */
  GeneralDetailReportType: GeneralDetailReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Allows you to report on specific transaction types (for example, charge, check, deposit, or estimate). */
  ReportTxnTypeFilter?: ReportTxnTypeFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeRowsBy` (along with `IncludeColumnList`, in most cases) determines what data is calculated for this report and controls how the rows are organized and labeled. For example, if you set the value to `srbAccount`, the report’s row labels might be “Checking,” “Savings,” and so on. */
  SummarizeRowsBy?: SummarizeRowsBy;
  /** A list of enum values showing which columns you want the report to return. (The report won’t return columns other than the ones you specify here.) */
  IncludeColumn?: IncludeColumn | IncludeColumn[];
  /** Indicates whether this report should include all accounts or just those that are currently in use. */
  IncludeAccounts?: IncludeAccounts;
  /** The report will return open balance information up to the `ReportOpenBalanceAsOf` date. */
  ReportOpenBalanceAsOf?: ReportOpenBalanceAsOf;
  /** If `ReportBasis` is `rbCash`, the report bases income and expenses on the dates when money changed hands.`rbAccrual`, the report bases income on the dates when customers were invoiced and bases expenses on the dates when bills were entered.`rbNone`, the report uses the default `ReportBasis`, which is either the QuickBooks Preference setting or the QuickBooks default for a given type of report. In a report response, the SDK returns `rbNone` for reports that do not support `ReportBasis`. (The 1099 report, for example, has its own basis for generation.) */
  ReportBasis?: ReportBasis;
}

export interface GeneralDetailReportQueryRs {
  ReportRet: ReportRet[];
}

export type GeneralDetailReportType =
  | "1099Detail"
  | "AuditTrail"
  | "BalanceSheetDetail"
  | "CheckDetail"
  | "CustomerBalanceDetail"
  | "DepositDetail"
  | "EstimatesByJob"
  | "ExpenseByVendorDetail"
  | "GeneralLedger"
  | "IncomeByCustomerDetail"
  | "IncomeTaxDetail"
  | "InventoryValuationDetail"
  | "JobProgressInvoicesVsEstimates"
  | "Journal"
  | "MissingChecks"
  | "OpenInvoices"
  | "OpenPOs"
  | "OpenPOsByJob"
  | "OpenSalesOrderByCustomer"
  | "OpenSalesOrderByItem"
  | "PendingSales"
  | "ProfitAndLossDetail"
  | "PurchaseByItemDetail"
  | "PurchaseByVendorDetail"
  | "SalesByCustomerDetail"
  | "SalesByItemDetail"
  | "SalesByRepDetail"
  | "TxnDetailByAccount"
  | "TxnListByCustomer"
  | "TxnListByDate"
  | "TxnListByVendor"
  | "UnbilledCostsByJob"
  | "UnpaidBillsDetail"
  | "VendorBalanceDetail";

export interface GeneralSummaryReportQueryRq {
  /** The type of general summary report being queried. The report types listed below map almost directly to named reports in QuickBooks. */
  GeneralSummaryReportType: GeneralSummaryReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Allows you to report on specific transaction types (for example, charge, check, deposit, or estimate). */
  ReportTxnTypeFilter?: ReportTxnTypeFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeColumnsBy` determines which data the report calculates and how the columns will be labeled across the top of the report. For example, if you set the value to `scbTwoWeek`, the report’s column labels might be “Feb 10-23, 02,” “Feb 24-Mar9, 02,” and so on. */
  SummarizeColumnsBy?: SummarizeColumnsBy;
  /** The default value is false, which means that the report will not include any subcolumn information. To include all available types of subcolumns for this report, set `IncludeSubcolumns` to true. The SDK will not return subcolumn information for data that can be easily computed. (For example, the SDK does not return the “percent of row” column.) */
  IncludeSubcolumns?: boolean;
  /** Specifies the type of year that will be used for this report. */
  ReportCalendar?: ReportCalendar;
  /** Specifies whether you want the report to include only rows with active information, only rows with nonzero values, or all rows regardless of their content or active status. */
  ReturnRows?: ReturnRows;
  /** Specifies whether you want the report to include only columns with active information, only columns with nonzero values, or all columns regardless of their content or active status. */
  ReturnColumns?: ReturnColumns;
  /** If `ReportBasis` is `rbCash`, the report bases income and expenses on the dates when money changed hands.`rbAccrual`, the report bases income on the dates when customers were invoiced and bases expenses on the dates when bills were entered.`rbNone`, the report uses the default `ReportBasis`, which is either the QuickBooks Preference setting or the QuickBooks default for a given type of report. In a report response, the SDK returns `rbNone` for reports that do not support `ReportBasis`. (The 1099 report, for example, has its own basis for generation.) */
  ReportBasis?: ReportBasis;
}

export interface GeneralSummaryReportQueryRs {
  ReportRet: ReportRet[];
}

export type GeneralSummaryReportType =
  | "BalanceSheetByClass"
  | "BalanceSheetPrevYearComp"
  | "BalanceSheetStandard"
  | "BalanceSheetSummary"
  | "CustomerBalanceSummary"
  | "ExpenseByVendorSummary"
  | "IncomeByCustomerSummary"
  | "IncomeTaxSummary"
  | "InventoryStockStatusByItem"
  | "InventoryStockStatusByVendor"
  | "InventoryValuationSummary"
  | "InventoryValuationSummaryBySite"
  | "LotNumberInStockBySite"
  | "PhysicalInventoryWorksheet"
  | "ProfitAndLossByClass"
  | "ProfitAndLossByJob"
  | "ProfitAndLossPrevYearComp"
  | "ProfitAndLossStandard"
  | "ProfitAndLossYTDComp"
  | "PurchaseByItemSummary"
  | "PurchaseByVendorSummary"
  | "SalesByCustomerSummary"
  | "SalesByItemSummary"
  | "SalesByRepSummary"
  | "SalesTaxLiability"
  | "SalesTaxRevenueSummary"
  | "SerialNumberInStockBySite"
  | "TrialBalance"
  | "VendorBalanceSummary";

export type IncludeAccounts = "All" | "InUse";

export type IncludeColumn =
  | "Account"
  | "Aging"
  | "Amount"
  | "AmountDifference"
  | "AverageCost"
  | "BilledDate"
  | "BillingStatus"
  | "CalculatedAmount"
  | "Class"
  | "ClearedStatus"
  | "CostPrice"
  | "Credit"
  | "Currency"
  | "Date"
  | "Debit"
  | "DeliveryDate"
  | "DueDate"
  | "EstimateActive"
  | "ExchangeRate"
  | "FOB"
  | "IncomeSubjectToTax"
  | "Invoiced"
  | "Item"
  | "ItemDesc"
  | "LastModifiedBy"
  | "LatestOrPriorState"
  | "Memo"
  | "ModifiedTime"
  | "Name"
  | "NameAccountNumber"
  | "NameAddress"
  | "NameCity"
  | "NameContact"
  | "NameEmail"
  | "NameFax"
  | "NamePhone"
  | "NameState"
  | "NameZip"
  | "OpenBalance"
  | "OriginalAmount"
  | "PaidAmount"
  | "PaidStatus"
  | "PaidThroughDate"
  | "PaymentMethod"
  | "PayrollItem"
  | "PONumber"
  | "PrintStatus"
  | "ProgressAmount"
  | "ProgressPercent"
  | "Quantity"
  | "QuantityAvailable"
  | "QuantityOnHand"
  | "QuantityOnSalesOrder"
  | "ReceivedQuantity"
  | "RefNumber"
  | "RunningBalance"
  | "SalesRep"
  | "SalesTaxCode"
  | "SerialOrLotNumber"
  | "ShipDate"
  | "ShipMethod"
  | "SourceName"
  | "SplitAccount"
  | "SSNOrTaxID"
  | "TaxLine"
  | "TaxTableVersion"
  | "Terms"
  | "TxnID"
  | "TxnNumber"
  | "TxnType"
  | "UnitPrice"
  | "UserEdit"
  | "ValueOnHand"
  | "WageBase"
  | "WageBaseTips";

export interface IncomeAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface InventoryAdjustmentAdd {
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Additional information. */
  Memo?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IInventoryAdjustmentLine` objects, each representing one line in the inventory adjustment transaction. */
  InventoryAdjustmentLineAdd:
    | InventoryAdjustmentLineAdd
    | InventoryAdjustmentLineAdd[];
}

export interface InventoryAdjustmentAddRq {
  InventoryAdjustmentAdd: InventoryAdjustmentAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InventoryAdjustmentAddRs {
  InventoryAdjustmentRet?: InventoryAdjustmentRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface InventoryAdjustmentLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** Adjusts the inventory quantity either by setting a new quantity or by adjusting the current quantity up or down. */
  QuantityAdjustment?: QuantityAdjustment;
  /** Adjusts the total value of these inventory items by setting a new monetary value, and optionally by setting a new quantity. */
  ValueAdjustment?: ValueAdjustment;
  /** Serial number that will be adjusted in inventory. */
  SerialNumberAdjustment?: SerialNumberAdjustment;
  /** Amount to adjust lot number. */
  LotNumberAdjustment?: LotNumberAdjustment;
}

export interface InventoryAdjustmentLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Amount to adjust count. */
  CountAdjustment?: number;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** Either a positive or negative number that shows the change in quantity for this inventory item. */
  QuantityDifference?: number;
  /** Either a positive or negative number that shows a change in the total value of the entire stock of this inventory item. */
  ValueDifference?: string;
}

export interface InventoryAdjustmentLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** Serial number that was added or removed from inventory. */
  SerialNumberAddedOrRemoved?: SerialNumberAddedOrRemoved;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** Either a positive or negative number that shows the change in quantity for this inventory item. */
  QuantityDifference: number;
  /** Either a positive or negative number that shows a change in the total value of the entire stock of this inventory item. */
  ValueDifference: string;
}

export interface InventoryAdjustmentMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Additional information. */
  Memo?: string;
  /** A list of `IInventoryAdjustmentLine` objects, each representing one line in the inventory adjustment transaction. */
  InventoryAdjustmentLineMod?:
    | InventoryAdjustmentLineMod
    | InventoryAdjustmentLineMod[];
}

export interface InventoryAdjustmentModRq {
  InventoryAdjustmentMod: InventoryAdjustmentMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InventoryAdjustmentModRs {
  InventoryAdjustmentRet?: InventoryAdjustmentRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface InventoryAdjustmentQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to the item name or ID. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. */
  ItemFilter?: ItemFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface InventoryAdjustmentQueryRs {
  InventoryAdjustmentRet: InventoryAdjustmentRet[];
}

export interface InventoryAdjustmentRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef: AccountRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Additional information. */
  Memo?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IInventoryAdjustmentLine` objects, each representing one line in the inventory adjustment transaction. */
  InventoryAdjustmentLineRet?:
    | InventoryAdjustmentLineRet
    | InventoryAdjustmentLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface InventorySiteAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentSiteRef?: ParentSiteRef;
  /** Description of the site. */
  SiteDesc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The telephone number. */
  Phone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  SiteAddress?: SiteAddress;
}

export interface InventorySiteAddRq {
  InventorySiteAdd: InventorySiteAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InventorySiteAddRs {
  InventorySiteRet?: InventorySiteRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface InventorySiteLocationRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface InventorySiteMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentSiteRef?: ParentSiteRef;
  /** Description of the site. */
  SiteDesc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The telephone number. */
  Phone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  SiteAddress?: SiteAddress;
}

export interface InventorySiteModRq {
  InventorySiteMod: InventorySiteMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InventorySiteModRs {
  InventorySiteRet?: InventorySiteRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface InventorySiteQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InventorySiteQueryRs {
  InventorySiteRet: InventorySiteRet[];
}

export interface InventorySiteRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface InventorySiteRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentSiteRef?: ParentSiteRef;
  /** If site is marked as default, this will be the site used if not specified. */
  IsDefaultSite?: boolean;
  /** Description of the site. */
  SiteDesc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The telephone number. */
  Phone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  SiteAddress?: SiteAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  SiteAddressBlock?: SiteAddressBlock;
}

export interface InvoiceAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the invoice. If you leave `TxnDate` out of an `InvoiceAdd` message, QuickBooks might prefill it with the date of the invoice that was most recently saved. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsPending` is set to true, the invoice has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. */
  IsPending?: boolean;
  /** If `IsFinanceCharge` is true, a finance-charge item has been added to the invoice. */
  IsFinanceCharge?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** If `DueDate` is not included in an `InvoiceAdd` request, QuickBooks might determine the due date according to the terms set for this customer. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Message that appears in reports, but not on the invoice. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** The `LinkToTxnID` aggregate allows to link an entire transaction. If you want to link individual lines in a transaction, use the `LinkToTxn` aggregate. You can use both `LinkToTxnID` and `LinkToTxn` aggregates in the same request, as long as these aggregates do NOT link to the same `TxnID`. If both aggregates are used and do link to the same `TxnID`, you receive an error 3000. Also, if you attempt to invoke `LinkToTxnID` with the same `TxnID`, more than once, you get an error 3177. If the transaction specified by `LinkToTxnID` is already closed or fully received and the `ItemReceiptAdd` request does not contain any other lines, you get error 3180 for attempting to save an empty transaction. You get a warning if you attempt to link to a transaction that’s already closed. */
  LinkToTxnID?: string[] | string;
  /** A list of credits to set. Setting, or applying, a credit means using an available credit to lower the balance of a transaction such as an invoice or a bill. (Creating a credit, on the other hand, means making a credit available to be applied in the future.) Notice that if you use a credit (`SetCredit`) only, in your `ReceivePaymentAdd` or `BillPaymentCreditCardAdd` request, then no transaction ID is created, because, from the viewpoint of QuickBooks, there was no transaction. Setting a credit merely creates links between existing transactions (for example, between a credit memo transaction and an invoice transaction), and no information about these links will be returned to you in the response. If you need to retrieve which transactions were linked in the `SetCredit`, for Bill Payment, you must do a `BillQuery` and specify `IncludeLinkedTxns`. */
  SetCredit?: SetCredit | SetCredit[];
  /** Represents one line in the invoice. Compare with `InvoiceLineGroup`, which represents a previously defined group of lines in the invoice. */
  InvoiceLineAdd?: InvoiceLineAdd | InvoiceLineAdd[];
  /** Represents a previously defined group of lines in the invoice. Compare with `InvoiceLine`, which represents just one line in the invoice. */
  InvoiceLineGroupAdd?: InvoiceLineGroupAdd | InvoiceLineGroupAdd[];
}

export interface InvoiceAddRq {
  InvoiceAdd: InvoiceAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InvoiceAddRs {
  InvoiceRet?: InvoiceRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface InvoiceLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add or Mod request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** When used with `InvoiceAdd`, the transaction you are linking to via this field must be a `SalesOrder`; links to other transactions, such as to estimates, are not currently supported. When used with `BillAdd` or `ItemReceiptAdd`, the transaction you are linking to via this field must be a `PurchaseOrder`: links to other transactions are not currently supported. The `LinkToTxn` aggregate allows you to bring in a specific line item from a transaction. If you want to link an entire transaction and bring in all its lines, use the `LinkToTxnID` aggregate. Notice that if you use `LinkToTxn` in the item line, you cannot use `ItemRef` in that line: you’ll get a runtime error. `LinkToTxn` brings in all the item information you need. (You can, however, specify whatever quantity or rate that you want, or any other item line element other than `ItemRef`. You can use both `LinkToTxnID` and `LinkToTxn` in the same request, as long as these do NOT link to the same `TxnID`. You get an error if the transaction specified by `LinkToTxnID` is already closed or fully received and the request does not contain any other lines. You get error if you attempt to save an empty transaction. You get a warning if you attempt to link to a transaction that’s already closed. For a complete set of rules and instructions on transaction linking, see the chapter on transaction linking in the QB SDK Programmer’s Guide (PDF, 9.6 MB). */
  LinkToTxn?: LinkToTxn;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface InvoiceLineGroupAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface InvoiceLineGroupMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** Quantity For transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `IInvoiceLineRet` objects, each representing one line in this group of invoice lines. */
  InvoiceLineMod?: InvoiceLineMod | InvoiceLineMod[];
}

export interface InvoiceLineGroupRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup: boolean;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `IInvoiceLineRet` objects, each representing one line in this group of invoice lines. */
  InvoiceLineRet?: InvoiceLineRet | InvoiceLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface InvoiceLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items.

  Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** Quantity For transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add or Mod request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.)

  The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders.

  Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
}

export interface InvoiceLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items.

  Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add or Mod request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface InvoiceMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the invoice. If you leave `TxnDate` out of an `InvoiceAdd` message, QuickBooks might prefill it with the date of the invoice that was most recently saved. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsPending` is set to true, the invoice has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. */
  IsPending?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** If `DueDate` is not included in an `InvoiceAdd` request, QuickBooks might determine the due date according to the terms set for this customer. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward.

  When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate.

  One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Message that appears in reports, but not on the invoice. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once.

  Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch.

  Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** A list of credits to set. Setting, or applying, a credit means using an available credit to lower the balance of a transaction such as an invoice or a bill. (Creating a credit, on the other hand, means making a credit available to be applied in the future.)

  Notice that if you use a credit (`SetCredit`) only, in your `ReceivePaymentAdd` or `BillPaymentCreditCardAdd` request, then no transaction ID is created, because, from the viewpoint of QuickBooks, there was no transaction. Setting a credit merely creates links between existing transactions (for example, between a credit memo transaction and an invoice transaction), and no information about these links will be returned to you in the response.

  If you need to retrieve which transactions were linked in the `SetCredit`, for Bill Payment, you must do a `BillQuery` and specify `IncludeLinkedTxns`. */
  SetCredit?: SetCredit | SetCredit[];
  /** Represents one line in the invoice. Compare with `InvoiceLineGroup`, which represents a previously defined group of lines in the invoice. */
  InvoiceLineMod?: InvoiceLineMod;
  /** Represents a previously defined group of lines in the invoice. Compare with `InvoiceLine`, which represents just one line in the invoice. */
  InvoiceLineGroupMod?: InvoiceLineGroupMod;
}

export interface InvoiceModRq {
  InvoiceMod: InvoiceMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface InvoiceModRs {
  InvoiceRet?: InvoiceRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface InvoiceQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** Allows you to filter for transactions according to whether or not they are paid. */
  PaidStatus?: PaidStatus;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface InvoiceQueryRs {
  InvoiceRet: InvoiceRet[];
}

export interface InvoiceRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the invoice. If you leave `TxnDate` out of an `InvoiceAdd` message, QuickBooks might prefill it with the date of the invoice that was most recently saved. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  BillAddressBlock?: BillAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines.

  There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode. Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query)

  If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** If `IsPending` is set to true, the invoice has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. */
  IsPending?: boolean;
  /** If `IsFinanceCharge` is true, a finance-charge item has been added to the invoice. */
  IsFinanceCharge?: boolean;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** If `DueDate` is not included in an `InvoiceAdd` request, QuickBooks might determine the due date according to the terms set for this customer. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** The total of all the invoice lines, before taxes and `AppliedAmount` are applied. (By contrast, a subtotal item (an `ItemSubtotal` object) gives only the total of the amounts in the lines that appear above it.) */
  Subtotal?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward.

  When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate.

  One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The percentage charged for sales tax. */
  SalesTaxPercentage?: string;
  /** The total amount of sales tax charged. */
  SalesTaxTotal?: string;
  /** Amount of credit that is applied to the customer’s invoice, or amount that the customer has paid on this invoice. */
  AppliedAmount?: string;
  /** The outstanding balance on this invoice. `BalanceRemaining` = (`Subtotal` + `SalesTaxTotal`) – `AppliedAmount`. */
  BalanceRemaining?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Balance remaining in units of the home currency. */
  BalanceRemainingInHomeCurrency?: string;
  /** Message that appears in reports, but not on the invoice. */
  Memo?: string;
  /** If `IsPaid` is true, this transaction has been paid. */
  IsPaid?: boolean;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once.

  Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch.

  Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** The suggested discount for this invoice. */
  SuggestedDiscountAmount?: string;
  /** The date when `SuggestedDiscountAmount` would apply. */
  SuggestedDiscountDate?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it.

  The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line.

  These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!)

  Note: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available.

  Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty.

  The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** Represents one line in the invoice. Compare with `InvoiceLineGroup`, which represents a previously defined group of lines in the invoice. */
  InvoiceLineRet?: InvoiceLineRet | InvoiceLineRet[];
  /** Represents a previously defined group of lines in the invoice. Compare with `InvoiceLine`, which represents just one line in the invoice. */
  InvoiceLineGroupRet?: InvoiceLineGroupRet | InvoiceLineGroupRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemDiscountAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The discount rate when it is given as a monetary amount. `DiscountRate` will be subtracted from a total or subtotal. */
  DiscountRate?: string;
  /** The discount rate when it is given as a percent. `DiscountRatePercent` will be subtracted from a total or subtotal. */
  DiscountRatePercent?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemDiscountAddRq {
  ItemDiscountAdd: ItemDiscountAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemDiscountAddRs {
  ItemDiscountRet?: ItemDiscountRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemDiscountMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The discount rate when it is given as a monetary amount. `DiscountRate` will be subtracted from a total or subtotal. */
  DiscountRate?: string;
  /** The discount rate when it is given as a percent. `DiscountRatePercent` will be subtracted from a total or subtotal. */
  DiscountRatePercent?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Used to support changing the `AccountRef` in the Mod request. When you do this, the QuickBooks UI normally displays a prompt asking whether the change should apply to existing transactions or not. Specifying False basically dismisses this with a “No” answer; specifying True dismisses it with a “Yes” answer and then changes the existing transactions that use the item with that `AccountRef`. Setting this to “True” should be used with caution and normally only after some user has indicated that they want those changes made to all those existing transactions! If any affected transactions are protected by a closing date and password, the `AccountRef` changes will not be made and so the Mod request will return an error without making the requested Mod. */
  ApplyAccountRefToExistingTxns?: boolean;
}

export interface ItemDiscountModRq {
  ItemDiscountMod: ItemDiscountMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemDiscountModRs {
  ItemDiscountRet?: ItemDiscountRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemDiscountQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemDiscountQueryRs {
  ItemDiscountRet: ItemDiscountRet[];
}

export interface ItemDiscountRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The discount rate when it is given as a monetary amount. `DiscountRate` will be subtracted from a total or subtotal. */
  DiscountRate?: string;
  /** The discount rate when it is given as a percent. `DiscountRatePercent` will be subtracted from a total or subtotal. */
  DiscountRatePercent?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

export interface ItemFixedAssetAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Indicates whether this item was new or used when the business acquired it. */
  AcquiredAs: AcquiredAs;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc: string;
  /** The date when this asset was purchased. */
  PurchaseDate: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** The name of the vendor from whom this asset was purchased. */
  VendorOrPayeeName?: string;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** Sales information, if this fixed asset was sold. */
  FixedAssetSalesInfo?: FixedAssetSalesInfo;
  /** Description of the asset—maker, brand, and so on. */
  AssetDesc?: string;
  /** Where the asset is located or has been placed into service. */
  Location?: string;
  /** Purchase order number. */
  PONumber?: string;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The date when the warranty for this asset expires. */
  WarrantyExpDate?: string;
  /** Additional information. */
  Notes?: string;
  /** The number used by the QuickBooks Fixed Asset Manager to identify this asset. */
  AssetNumber?: string;
  /** The total cost of the fixed asset. This can include the cost of improvements or repairs. This amount is used to figure depreciation. */
  CostBasis?: string;
  /** The amount the fixed asset has lost in value since it was purchased, as of the end of the year. */
  YearEndAccumulatedDepreciation?: string;
  /** A reasonable estimate of the sales value of the fixed asset, as of the end of the year. */
  YearEndBookValue?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemFixedAssetAddRq {
  ItemFixedAssetAdd: ItemFixedAssetAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemFixedAssetAddRs {
  ItemFixedAssetRet?: ItemFixedAssetRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemFixedAssetMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Indicates whether this item was new or used when the business acquired it. */
  AcquiredAs?: AcquiredAs;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc?: string;
  /** The date when this asset was purchased. */
  PurchaseDate?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** The name of the vendor from whom this asset was purchased. */
  VendorOrPayeeName?: string;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** Sales information, if this fixed asset was sold. */
  FixedAssetSalesInfoMod?: FixedAssetSalesInfoMod;
  /** Description of the asset—maker, brand, and so on. */
  AssetDesc?: string;
  /** Where the asset is located or has been placed into service. */
  Location?: string;
  /** Purchase order number. */
  PONumber?: string;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The date when the warranty for this asset expires. */
  WarrantyExpDate?: string;
  /** Additional information. */
  Notes?: string;
  /** The number used by the QuickBooks Fixed Asset Manager to identify this asset. */
  AssetNumber?: string;
  /** The total cost of the fixed asset. This can include the cost of improvements or repairs. This amount is used to figure depreciation. */
  CostBasis?: string;
  /** The amount the fixed asset has lost in value since it was purchased, as of the end of the year. */
  YearEndAccumulatedDepreciation?: string;
  /** A reasonable estimate of the sales value of the fixed asset, as of the end of the year. */
  YearEndBookValue?: string;
}

export interface ItemFixedAssetModRq {
  ItemFixedAssetMod: ItemFixedAssetMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemFixedAssetModRs {
  ItemFixedAssetRet?: ItemFixedAssetRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemFixedAssetQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemFixedAssetQueryRs {
  ItemFixedAssetRet: ItemFixedAssetRet[];
}

export interface ItemFixedAssetRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Indicates whether this item was new or used when the business acquired it. */
  AcquiredAs: AcquiredAs;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc: string;
  /** The date when this asset was purchased. */
  PurchaseDate: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** The name of the vendor from whom this asset was purchased. */
  VendorOrPayeeName?: string;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** Sales information, if this fixed asset was sold. */
  FixedAssetSalesInfo?: FixedAssetSalesInfo;
  /** Description of the asset—maker, brand, and so on. */
  AssetDesc?: string;
  /** Where the asset is located or has been placed into service. */
  Location?: string;
  /** Purchase order number. */
  PONumber?: string;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The date when the warranty for this asset expires. */
  WarrantyExpDate?: string;
  /** Additional information. */
  Notes?: string;
  /** The number used by the QuickBooks Fixed Asset Manager to identify this asset. */
  AssetNumber?: string;
  /** The total cost of the fixed asset. This can include the cost of improvements or repairs. This amount is used to figure depreciation. */
  CostBasis?: string;
  /** The amount the fixed asset has lost in value since it was purchased, as of the end of the year. */
  YearEndAccumulatedDepreciation?: string;
  /** A reasonable estimate of the sales value of the fixed asset, as of the end of the year. */
  YearEndBookValue?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemGroupAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IItemGroupLine` objects, each representing one descriptive line of this item. */
  ItemGroupLine?: ItemGroupLine | ItemGroupLine[];
}

export interface ItemGroupAddRq {
  ItemGroupAdd: ItemGroupAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemGroupAddRs {
  ItemGroupRet?: ItemGroupRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemGroupLine {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
}

export interface ItemGroupLineAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface ItemGroupLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `IItemLineRet` objects, each representing one line of the item. Each item line is used to track a portion of a transaction that represents the purchase of an “item.” */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
}

export interface ItemGroupLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `IItemLineRet` objects, each representing one line of the item. Each item line is used to track a portion of a transaction that represents the purchase of an “item.” */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface ItemGroupMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** By Default `ForceUOMChange` is false. However, in item Mod requests, you need to set the `ForceUOMChange` field to True if you are changing the UOM set and the base unit of the new set does not match the base unit of the UOM set currently assigned to the item. This does the same thing as the user accepting the warning prompt in the UI. If you don’t set `ForceUOMChange` to True, you’ll get an error when you invoke the Item* Mod request.Y You should be aware that if you change the base unit for an item, you should also change the item’s quantities on hand and cost to reflect the new unit; otherwise the values will be inaccurate. An alternative to handle such UOM changes to an item is to create a new item with the desired UOM set and inactivate the old item. */
  ForceUOMChange?: boolean;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup?: boolean;
  /** Set to true to clear all the items in this group. */
  ClearItemsInGroup?: boolean;
  /** A list of `IItemGroupLine` objects, each representing one descriptive line of this item. */
  ItemGroupLine?: ItemGroupLine | ItemGroupLine[];
}

export interface ItemGroupModRq {
  ItemGroupMod: ItemGroupMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemGroupModRs {
  ItemGroupRet?: ItemGroupRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemGroupQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemGroupQueryRs {
  ItemGroupRet: ItemGroupRet[];
}

export interface ItemGroupRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemGroupRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup?: boolean;
  /** Identifies the type of special item. See type for possible enum values. */
  SpecialItemType?: SpecialItemType;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IItemGroupLine` objects, each representing one descriptive line of this item. */
  ItemGroupLine?: ItemGroupLine | ItemGroupLine[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemInventoryAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Appears in the `Description` column of checks, bills, credit card charges, and item receipts when this item is reordered. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to the account that QuickBooks uses to track the original cost of goods that are eventually sold. (The `AccountType` of this account will be `CostOfGoodsSold`.) In a request, if a `COGSAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  COGSAccountRef?: COGSAccountRef;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** Quantity at which QuickBooks will remind the user to reorder this inventory item. */
  ReorderPoint?: number;
  /** Maximum number of items in inventory. */
  Max?: number;
  /** The number of these items in inventory. `QuantityOnHand` times `AverageCost` is `TotalValue` in an inventory item list. To change the `QuantityOnHand` for an item, you would have to use `InventoryAdjustmentAdd` not an `ItemInventoryMod`. */
  QuantityOnHand?: number;
  /** The total value of this inventory. If `TotalValue` is included, `QuantityOnHand` must also be included and must be greater than zero. If both `QuantityOnHand` and `PurchaseCost` are included, then `TotalValue` will be set to `QuantityOnHand` times `PurchaseCost`, regardless of what `TotalValue` is explicitly set to. */
  TotalValue?: string;
  /** The date when an item was converted into an inventory item from some other type of item. */
  InventoryDate?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemInventoryAddRq {
  ItemInventoryAdd: ItemInventoryAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemInventoryAddRs {
  ItemInventoryRet?: ItemInventoryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemInventoryAssemblyAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to the account that QuickBooks uses to track the original cost of goods that are eventually sold. (The `AccountType` of this account will be `CostOfGoodsSold`.) In a request, if a `COGSAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  COGSAccountRef?: COGSAccountRef;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** The build notification point. The QuickBooks user will receive a notification when `QuantityOnHand` plus `QuantityOnOrder` falls below `BuildPoint`. */
  BuildPoint?: number;
  /** Maximum number of items in inventory. */
  Max?: number;
  /** The number of these items in inventory. `QuantityOnHand` times `AverageCost` is `TotalValue` in an inventory item list. To change the `QuantityOnHand` for an item, you would have to use `InventoryAdjustmentAdd` not an `ItemInventoryMod`. */
  QuantityOnHand?: number;
  /** The total value of this inventory. If `TotalValue` is included, `QuantityOnHand` must also be included and must be greater than zero. If both `QuantityOnHand` and `PurchaseCost` are included, then `TotalValue` will be set to `QuantityOnHand` times `PurchaseCost`, regardless of what `TotalValue` is explicitly set to. */
  TotalValue?: string;
  /** The date when an item was converted into an inventory item from some other type of item. */
  InventoryDate?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IItemInventoryAssemblyLine` objects, each representing one line in the inventory-assembly item. */
  ItemInventoryAssemblyLine?:
    | ItemInventoryAssemblyLine
    | ItemInventoryAssemblyLine[];
}

export interface ItemInventoryAssemblyAddRq {
  ItemInventoryAssemblyAdd: ItemInventoryAssemblyAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemInventoryAssemblyAddRs {
  ItemInventoryAssemblyRet?: ItemInventoryAssemblyRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemInventoryAssemblyLine {
  /** An inventory item is any merchandise or part that a business purchases, tracks as inventory, and then resells. In QuickBooks, information about an inventory item is grouped into three categories:Puchase Information includes `PurchaseDesc`, `PurchaseCost`, `COGSAccountRef`, and `PrefVendorRef`. Sales Information includes `SalesDesc`, `SalesPrice`, and `SalesTaxCodeRef`. Inventory Information includes `AssetAccountRef`, `ReorderPoint`, `QuantityOnHand`, `TotalValue`, and `InventoryDate`. The Life Cycle of Inventory Items and Effects of Sales and Purchases The value of inventory is set when an inventory item is created or bought. QuickBooks uses cost averaging and decreases the value of the inventory asset account at the price when the sale is recorded. So, lets say a company starts carrying widgets as inventory items. First the inventory item must be created in QuickBooks. If the widgets are already in inventory based on a purchase made that will not be recorded in QuickBooks, the user or application would add the inventory item description along with the quantity on hand and the value (total purchase price) of the quantity on hand. If the purchase is to be recorded in QuickBooks the inventory item would be created with quantity and value of 0 (zero). Then a bill would be added to QB which would increase the inventory quantity and value. Lets say we bought 10 widgets for $100. QuickBooks would then consider each widget to be worth $10. The next day a customer buys 5 widgets for $20 each. A sales receipt or invoice is created for the purchase, the quantity of widgets is reduced by 5, to 5 and the value is reduced by $50 to $50. The inventory asset account is reduced by $50 and the undeposited funds or accounts receivable account is increased by $100. It appears that widgets will be a big seller, so the small business owner goes out and buys 10 more widgets. However, the supplier has also noticed a widget buying trend, so he’s increased the price to $25 each. So now our quantity is increased from 5 to 15 and the value is increased from $50 to $300, so they are considered to be worth $20 each. After purchasing the widgets another customer decides to buy 10 widgets but the price has been raised to $50 each. After the sales receipt or invoice is entered, the inventory is reduced to 5 and the value is reduced to $100. The inventory asset account is reduced by $200 and the undeposited funds or accounts receivable account is increased by $500. An `ItemInventoryRef` aggregate refers to an inventory item. In a request, if an `ItemInventoryRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemInventoryRef: ItemInventoryRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
}

export interface ItemInventoryAssemblyMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** By Default `ForceUOMChange` is false. However, in item Mod requests, you need to set the `ForceUOMChange` field to True if you are changing the UOM set and the base unit of the new set does not match the base unit of the UOM set currently assigned to the item. This does the same thing as the user accepting the warning prompt in the UI. If you don’t set `ForceUOMChange` to True, you’ll get an error when you invoke the Item* Mod request.Y You should be aware that if you change the base unit for an item, you should also change the item’s quantities on hand and cost to reflect the new unit; otherwise the values will be inaccurate. An alternative to handle such UOM changes to an item is to create a new item with the desired UOM set and inactivate the old item. */
  ForceUOMChange?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Used to support changing the `AccountRef` in the Mod request. When you do this, the QuickBooks UI normally displays a prompt asking whether the change should apply to existing transactions or not. Specifying False basically dismisses this with a “No” answer; specifying True dismisses it with a “Yes” answer and then changes the existing transactions that use the item with that `AccountRef`. Setting this to “True” should be used with caution and normally only after some user has indicated that they want those changes made to all those existing transactions! If any affected transactions are protected by a closing date and password, the `AccountRef` changes will not be made and so the Mod request will return an error without making the requested Mod. */
  ApplyIncomeAccountRefToExistingTxns?: boolean;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to the account that QuickBooks uses to track the original cost of goods that are eventually sold. (The `AccountType` of this account will be `CostOfGoodsSold`.) In a request, if a `COGSAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  COGSAccountRef?: COGSAccountRef;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** The build notification point. The QuickBooks user will receive a notification when `QuantityOnHand` plus `QuantityOnOrder` falls below `BuildPoint`. */
  BuildPoint?: number;
  /** Maximum number of items in inventory. */
  Max?: number;
  /** Set to true to clear all the items in this group. */
  ClearItemsInGroup?: boolean;
  /** A list of `IItemInventoryAssemblyLine` objects, each representing one line in the inventory-assembly item. */
  ItemInventoryAssemblyLine?:
    | ItemInventoryAssemblyLine
    | ItemInventoryAssemblyLine[];
}

export interface ItemInventoryAssemblyModRq {
  ItemInventoryAssemblyMod: ItemInventoryAssemblyMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemInventoryAssemblyModRs {
  ItemInventoryAssemblyRet?: ItemInventoryAssemblyRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemInventoryAssemblyQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemInventoryAssemblyQueryRs {
  ItemInventoryAssemblyRet: ItemInventoryAssemblyRet[];
}

export interface ItemInventoryAssemblyRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemInventoryAssemblyRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to the account that QuickBooks uses to track the original cost of goods that are eventually sold. (The `AccountType` of this account will be `CostOfGoodsSold`.) In a request, if a `COGSAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  COGSAccountRef?: COGSAccountRef;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** The build notification point. The QuickBooks user will receive a notification when `QuantityOnHand` plus `QuantityOnOrder` falls below `BuildPoint`. */
  BuildPoint?: number;
  /** Maximum number of items in inventory. */
  Max?: number;
  /** The number of these items in inventory. `QuantityOnHand` times `AverageCost` is `TotalValue` in an inventory item list. To change the `QuantityOnHand` for an item, you would have to use `InventoryAdjustmentAdd` not an `ItemInventoryMod`. */
  QuantityOnHand?: number;
  /** `AverageCost` is the total value of this item divided by `QuantityOnHand`. Initially the total value is the same as the `QuantityOnHand` times the `PurchaseCost` (so `AverageCost` equals `PurchaseCost`). However, the total value can be changed by an inventory adjustment so that it no longer matches `QuantityOnHand` times `PurchaseCost`. */
  AverageCost?: string;
  /** The number of these items that have been ordered from vendors (as recorded in purchase orders) but not received. */
  QuantityOnOrder?: number;
  /** The number of these items that have been sold (as recorded in sales orders) but not delivered to customers. */
  QuantityOnSalesOrder?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IItemInventoryAssemblyLine` objects, each representing one line in the inventory-assembly item. */
  ItemInventoryAssemblyLine?:
    | ItemInventoryAssemblyLine
    | ItemInventoryAssemblyLine[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemInventoryMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** By Default `ForceUOMChange` is false. However, in item Mod requests, you need to set the `ForceUOMChange` field to True if you are changing the UOM set and the base unit of the new set does not match the base unit of the UOM set currently assigned to the item. This does the same thing as the user accepting the warning prompt in the UI. If you don’t set `ForceUOMChange` to True, you’ll get an error when you invoke the Item* Mod request.Y You should be aware that if you change the base unit for an item, you should also change the item’s quantities on hand and cost to reflect the new unit; otherwise the values will be inaccurate. An alternative to handle such UOM changes to an item is to create a new item with the desired UOM set and inactivate the old item. */
  ForceUOMChange?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Used to support changing the `AccountRef` in the Mod request. When you do this, the QuickBooks UI normally displays a prompt asking whether the change should apply to existing transactions or not. Specifying False basically dismisses this with a “No” answer; specifying True dismisses it with a “Yes” answer and then changes the existing transactions that use the item with that `AccountRef`. Setting this to “True” should be used with caution and normally only after some user has indicated that they want those changes made to all those existing transactions! If any affected transactions are protected by a closing date and password, the `AccountRef` changes will not be made and so the Mod request will return an error without making the requested Mod. */
  ApplyIncomeAccountRefToExistingTxns?: boolean;
  /** Appears in the `Description` column of checks, bills, credit card charges, and item receipts when this item is reordered. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to the account that QuickBooks uses to track the original cost of goods that are eventually sold. (The `AccountType` of this account will be `CostOfGoodsSold`.) In a request, if a `COGSAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  COGSAccountRef?: COGSAccountRef;
  /** Effectively suppresses the UI prompt that is displayed upon a COGS account change when existing transactions use the account. */
  ApplyCOGSAccountRefToExistingTxns?: boolean;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** Quantity at which QuickBooks will remind the user to reorder this inventory item. */
  ReorderPoint?: number;
  /** Maximum number of items in inventory. */
  Max?: number;
}

export interface ItemInventoryModRq {
  ItemInventoryMod: ItemInventoryMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemInventoryModRs {
  ItemInventoryRet?: ItemInventoryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemInventoryQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemInventoryQueryRs {
  ItemInventoryRet: ItemInventoryRet[];
}

export interface ItemInventoryRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemInventoryRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Appears in the `Description` column of checks, bills, credit card charges, and item receipts when this item is reordered. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to the account that QuickBooks uses to track the original cost of goods that are eventually sold. (The `AccountType` of this account will be `CostOfGoodsSold`.) In a request, if a `COGSAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  COGSAccountRef?: COGSAccountRef;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
  /** Refers to the account QuickBooks uses to track the current value of the company’s inventory. (The `AccountType` of this account will be `FixedAsset`, `OtherAsset`, or `OtherCurrentAsset`.) In a request, if an `AssetAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  AssetAccountRef?: AssetAccountRef;
  /** Quantity at which QuickBooks will remind the user to reorder this inventory item. */
  ReorderPoint?: number;
  /** Maximum number of items in inventory. */
  Max?: number;
  /** The number of these items in inventory. `QuantityOnHand` times `AverageCost` is `TotalValue` in an inventory item list. To change the `QuantityOnHand` for an item, you would have to use `InventoryAdjustmentAdd` not an `ItemInventoryMod`. */
  QuantityOnHand?: number;
  /** `AverageCost` is the total value of this item divided by `QuantityOnHand`. Initially the total value is the same as the `QuantityOnHand` times the `PurchaseCost` (so `AverageCost` equals `PurchaseCost`). However, the total value can be changed by an inventory adjustment so that it no longer matches `QuantityOnHand` times `PurchaseCost`. */
  AverageCost?: string;
  /** The number of these items that have been ordered from vendors (as recorded in purchase orders) but not received. */
  QuantityOnOrder?: number;
  /** The number of these items that have been sold (as recorded in sales orders) but not delivered to customers. */
  QuantityOnSalesOrder?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to.

  For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If both `Quantity` and `Amount` are specified, QuickBooks will use them to calculate `Cost`. Likewise, if both `Quantity` and `Cost` are specified, QuickBooks will use them to calculate the total `Amount`. */
  Cost?: string;
  /** A monetary amount. */
  Amount?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** When used with `InvoiceAdd`, the transaction you are linking to via this field must be a `SalesOrder`; links to other transactions, such as to estimates, are not currently supported.

  When used with `BillAdd` or `ItemReceiptAdd`, the transaction you are linking to via this field must be a `PurchaseOrder`: links to other transactions are not currently supported. The `LinkToTxn` aggregate allows you to bring in a specific line item from a transaction. If you want to link an entire transaction and bring in all its lines, use the `LinkToTxnID` aggregate. Notice that if you use `LinkToTxn` in the item line, you cannot use `ItemRef` in that line: you’ll get a runtime error. `LinkToTxn` brings in all the item information you need. (You can, however, specify whatever quantity or rate that you want, or any other item line element other than `ItemRef`. You can use both `LinkToTxnID` and `LinkToTxn` in the same request, as long as these do NOT link to the same `TxnID`. You get an error if the transaction specified by `LinkToTxnID` is already closed or fully received and the request does not contain any other lines. You get error if you attempt to save an empty transaction. You get a warning if you attempt to link to a transaction that’s already closed. For a complete set of rules and instructions on transaction linking, see the chapter on transaction linking in the QB SDK Programmer’s Guide (PDF, 9.6 MB). */
  LinkToTxn?: LinkToTxn;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface ItemLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items.

  Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If both `Quantity` and `Amount` are specified, QuickBooks will use them to calculate `Cost`. Likewise, if both `Quantity` and `Cost` are specified, QuickBooks will use them to calculate the total `Amount`. */
  Cost?: string;
  /** A monetary amount. */
  Amount?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:

  In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
}

export interface ItemLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types.

  For example, here are some requests that impose limits on what items `ItemRef` can refer to.

  For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax items For `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item. For `BillingRateAdd` requests, the `ItemRef` must refer to a service item.

  You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If both `Quantity` and `Amount` are specified, QuickBooks will use them to calculate `Cost`. Likewise, if both `Quantity` and `Cost` are specified, QuickBooks will use them to calculate the total `Amount`. */
  Cost?: string;
  /** A monetary amount. */
  Amount?: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:

  In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default.

  A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:

  Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemNonInventoryAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchase?: SalesOrPurchase;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchase?: SalesAndPurchase;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemNonInventoryAddRq {
  ItemNonInventoryAdd: ItemNonInventoryAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemNonInventoryAddRs {
  ItemNonInventoryRet?: ItemNonInventoryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemNonInventoryMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** By Default `ForceUOMChange` is false. However, in item Mod requests, you need to set the `ForceUOMChange` field to True if you are changing the UOM set and the base unit of the new set does not match the base unit of the UOM set currently assigned to the item. This does the same thing as the user accepting the warning prompt in the UI. If you don’t set `ForceUOMChange` to True, you’ll get an error when you invoke the Item* Mod request.Y You should be aware that if you change the base unit for an item, you should also change the item’s quantities on hand and cost to reflect the new unit; otherwise the values will be inaccurate. An alternative to handle such UOM changes to an item is to create a new item with the desired UOM set and inactivate the old item. */
  ForceUOMChange?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchaseMod?: SalesOrPurchaseMod;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchaseMod?: SalesAndPurchaseMod;
}

export interface ItemNonInventoryModRq {
  ItemNonInventoryMod: ItemNonInventoryMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemNonInventoryModRs {
  ItemNonInventoryRet?: ItemNonInventoryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemNonInventoryQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemNonInventoryQueryRs {
  ItemNonInventoryRet: ItemNonInventoryRet[];
}

export interface ItemNonInventoryRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchase?: SalesOrPurchase;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchase?: SalesAndPurchase;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemOtherChargeAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchase?: SalesOrPurchase;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchase?: SalesAndPurchase;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemOtherChargeAddRq {
  ItemOtherChargeAdd: ItemOtherChargeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemOtherChargeAddRs {
  ItemOtherChargeRet?: ItemOtherChargeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemOtherChargeMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchaseMod?: SalesOrPurchaseMod;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchaseMod?: SalesAndPurchaseMod;
}

export interface ItemOtherChargeModRq {
  ItemOtherChargeMod: ItemOtherChargeMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemOtherChargeModRs {
  ItemOtherChargeRet?: ItemOtherChargeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemOtherChargeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemOtherChargeQueryRs {
  ItemOtherChargeRet: ItemOtherChargeRet[];
}

export interface ItemOtherChargeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchase?: SalesOrPurchase;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchase?: SalesAndPurchase;
  /** Identifies the type of special item. See type for possible enum values. */
  SpecialItemType?: SpecialItemType;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemPaymentAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemPaymentAddRq {
  ItemPaymentAdd: ItemPaymentAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemPaymentAddRs {
  ItemPaymentRet?: ItemPaymentRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemPaymentMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
}

export interface ItemPaymentModRq {
  ItemPaymentMod: ItemPaymentMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemPaymentModRs {
  ItemPaymentRet?: ItemPaymentRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemPaymentQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemPaymentQueryRs {
  ItemPaymentRet: ItemPaymentRet[];
}

export interface ItemPaymentRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemPurchaseTaxRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemReceiptAdd {
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef: VendorRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.) If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** The `LinkToTxnID` aggregate allows to link an entire transaction. If you want to link individual lines in a transaction, use the `LinkToTxn` aggregate. You can use both `LinkToTxnID` and `LinkToTxn` aggregates in the same request, as long as these aggregates do NOT link to the same `TxnID`. If both aggregates are used and do link to the same `TxnID`, you receive an error 3000. Also, if you attempt to invoke `LinkToTxnID` with the same `TxnID`, more than once, you get an error 3177. If the transaction specified by `LinkToTxnID` is already closed or fully received and the `ItemReceiptAdd` request does not contain any other lines, you get error 3180 for attempting to save an empty transaction. You get a warning if you attempt to link to a transaction that’s already closed. */
  LinkToTxnID?: string[] | string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineAdd?: ExpenseLineAdd | ExpenseLineAdd[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineAdd?: ItemLineAdd | ItemLineAdd[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineAdd?: ItemGroupLineAdd | ItemGroupLineAdd[];
}

export interface ItemReceiptAddRq {
  ItemReceiptAdd: ItemReceiptAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemReceiptAddRs {
  ItemReceiptRet?: ItemReceiptRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemReceiptMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef?: VendorRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.) If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Set `ClearExpenseLines` to true to clear all the expense lines. To modify individual lines, use `ExpenseLineMod`. */
  ClearExpenseLines?: boolean;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineMod?: ExpenseLineMod | ExpenseLineMod[];
  /** Set `ClearItemLines` to true to clear all the item lines. To modify individual lines, use `ItemLineMod`. */
  ClearItemLines?: boolean;
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineMod?: ItemGroupLineMod | ItemGroupLineMod[];
}

export interface ItemReceiptModRq {
  ItemReceiptMod: ItemReceiptMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemReceiptModRs {
  ItemReceiptRet?: ItemReceiptRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemReceiptQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemReceiptQueryRs {
  ItemReceiptRet: ItemReceiptRet[];
}

export interface ItemReceiptRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef: VendorRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.) If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** Refers to a liability account for this non-wage payroll item. */
  LiabilityAccountRef?: LiabilityAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Total amount of money paid or received in the home currency. */
  TotalAmountInHomeCurrency?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty. The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineRet?: ExpenseLineRet | ExpenseLineRet[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineRet?: ItemGroupLineRet | ItemGroupLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemSalesTaxAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** The tax rate. If a nonzero `TaxRate` is specified, then `TaxVendorRef` is required. */
  TaxRate?: string;
  /** Refers to the tax agency to whom collected taxes are owed. (This will be a vendor on the Vendor list.) If a nonzero `TaxRate` is specified, then `TaxVendorRef` is required. In a request, if a `TaxVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TaxVendorRef?: TaxVendorRef;
  /** Sales tax return line information. */
  SalesTaxReturnLineRef?: SalesTaxReturnLineRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemSalesTaxAddRq {
  ItemSalesTaxAdd: ItemSalesTaxAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemSalesTaxAddRs {
  ItemSalesTaxRet?: ItemSalesTaxRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemSalesTaxGroupAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of sales-tax items that are already defined in the `ItemSalesTax` list. */
  ItemSalesTaxRef: ItemSalesTaxRef | ItemSalesTaxRef[];
}

export interface ItemSalesTaxGroupAddRq {
  ItemSalesTaxGroupAdd: ItemSalesTaxGroupAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemSalesTaxGroupAddRs {
  ItemSalesTaxGroupRet?: ItemSalesTaxGroupRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemSalesTaxGroupMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** A list of sales-tax items that are already defined in the `ItemSalesTax` list. */
  ItemSalesTaxRef?: ItemSalesTaxRef | ItemSalesTaxRef[];
}

export interface ItemSalesTaxGroupModRq {
  ItemSalesTaxGroupMod: ItemSalesTaxGroupMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemSalesTaxGroupModRs {
  ItemSalesTaxGroupRet?: ItemSalesTaxGroupRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemSalesTaxGroupQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemSalesTaxGroupQueryRs {
  ItemSalesTaxGroupRet: ItemSalesTaxGroupRet[];
}

export interface ItemSalesTaxGroupRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of sales-tax items that are already defined in the `ItemSalesTax` list. */
  ItemSalesTaxRef?: ItemSalesTaxRef | ItemSalesTaxRef[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemSalesTaxMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** The tax rate. If a nonzero `TaxRate` is specified, then `TaxVendorRef` is required. */
  TaxRate?: string;
  /** Refers to the tax agency to whom collected taxes are owed. (This will be a vendor on the Vendor list.) If a nonzero `TaxRate` is specified, then `TaxVendorRef` is required. In a request, if a `TaxVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TaxVendorRef?: TaxVendorRef;
  /** Sales tax return line information. */
  SalesTaxReturnLineRef?: SalesTaxReturnLineRef;
}

export interface ItemSalesTaxModRq {
  ItemSalesTaxMod: ItemSalesTaxMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemSalesTaxModRs {
  ItemSalesTaxRet?: ItemSalesTaxRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemSalesTaxQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemSalesTaxQueryRs {
  ItemSalesTaxRet: ItemSalesTaxRet[];
}

export interface ItemSalesTaxRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemSalesTaxRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** The tax rate. If a nonzero `TaxRate` is specified, then `TaxVendorRef` is required. */
  TaxRate?: string;
  /** Refers to the tax agency to whom collected taxes are owed. (This will be a vendor on the Vendor list.) If a nonzero `TaxRate` is specified, then `TaxVendorRef` is required. In a request, if a `TaxVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TaxVendorRef?: TaxVendorRef;
  /** Sales tax return line information. */
  SalesTaxReturnLineRef?: SalesTaxReturnLineRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemServiceAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchase?: SalesOrPurchase;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchase?: SalesAndPurchase;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemServiceAddRq {
  ItemServiceAdd: ItemServiceAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemServiceAddRs {
  ItemServiceRet?: ItemServiceRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemServiceMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** By Default `ForceUOMChange` is false. However, in item Mod requests, you need to set the `ForceUOMChange` field to True if you are changing the UOM set and the base unit of the new set does not match the base unit of the UOM set currently assigned to the item. This does the same thing as the user accepting the warning prompt in the UI. If you don’t set `ForceUOMChange` to True, you’ll get an error when you invoke the Item* Mod request.Y You should be aware that if you change the base unit for an item, you should also change the item’s quantities on hand and cost to reflect the new unit; otherwise the values will be inaccurate. An alternative to handle such UOM changes to an item is to create a new item with the desired UOM set and inactivate the old item. */
  ForceUOMChange?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchaseMod?: SalesOrPurchaseMod;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchaseMod?: SalesAndPurchaseMod;
}

export interface ItemServiceModRq {
  ItemServiceMod: ItemServiceMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemServiceModRs {
  ItemServiceRet?: ItemServiceRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemServiceQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to the object’s class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemServiceQueryRs {
  ItemServiceRet: ItemServiceRet[];
}

export interface ItemServiceRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ItemServiceRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
  /** The unit of measure set consists of a base unit and 0-n related units. */
  UnitOfMeasureSetRef?: UnitOfMeasureSetRef;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** A `SalesOrPurchase` aggregate is used for items that are meant to be either purchased or sold, but not both. For example, a `SalesOrPurchase` aggregate would be used for a non-inventory item that is purchased but not sold, or for a service item that is sold but not purchased. */
  SalesOrPurchase?: SalesOrPurchase;
  /** A `SalesAndPurchase` aggregate is used for items that are meant to be both purchased and sold, such as an “other charge” item that is reimbursable. */
  SalesAndPurchase?: SalesAndPurchase;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface ItemSubtotalAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface ItemSubtotalAddRq {
  ItemSubtotalAdd: ItemSubtotalAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemSubtotalAddRs {
  ItemSubtotalRet?: ItemSubtotalRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemSubtotalMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** Barcode reference information. */
  BarCode?: BarCode;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
}

export interface ItemSubtotalModRq {
  ItemSubtotalMod: ItemSubtotalMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ItemSubtotalModRs {
  ItemSubtotalRet?: ItemSubtotalRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ItemSubtotalQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ItemSubtotalQueryRs {
  ItemSubtotalRet: ItemSubtotalRet[];
}

export interface ItemSubtotalRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Value of the barcode in the item. */
  BarCodeValue?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The description that will appear on a sales form when the item is used. */
  ItemDesc?: string;
  /** Identifies the type of special item. See type for possible enum values. */
  SpecialItemType?: SpecialItemType;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export type ItemTypeFilter =
  | "AllExceptFixedAsset"
  | "Assembly"
  | "Discount"
  | "FixedAsset"
  | "Inventory"
  | "InventoryAndAssembly"
  | "NonInventory"
  | "OtherCharge"
  | "Payment"
  | "Sales"
  | "SalesTax"
  | "Service";

export interface JobReportQueryRq {
  /** The type of job report. */
  JobReportType: JobReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Allows you to report on specific transaction types (for example, charge, check, deposit, or estimate). */
  ReportTxnTypeFilter?: ReportTxnTypeFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeColumnsBy` determines which data the report calculates and how the columns will be labeled across the top of the report. For example, if you set the value to `scbTwoWeek`, the report’s column labels might be “Feb 10-23, 02,” “Feb 24-Mar9, 02,” and so on. */
  SummarizeColumnsBy?: SummarizeColumnsBy;
  /** The default value is false, which means that the report will not include any subcolumn information. To include all available types of subcolumns for this report, set `IncludeSubcolumns` to true. The SDK will not return subcolumn information for data that can be easily computed. (For example, the SDK does not return the “percent of row” column.) */
  IncludeSubcolumns?: boolean;
}

export interface JobReportQueryRs {
  ReportRet: ReportRet[];
}

export type JobReportType =
  | "ItemEstimatesVsActuals"
  | "ItemProfitability"
  | "JobEstimatesVsActualsDetail"
  | "JobEstimatesVsActualsSummary"
  | "JobProfitabilityDetail"
  | "JobProfitabilitySummary,";

/** @default: None */
export type JobStatus =
  | "Awarded"
  | "Closed"
  | "InProgress"
  | "None"
  | "NotAwarded"
  | "Pending";

export interface JobTypeAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
}

export interface JobTypeAddRq {
  JobTypeAdd: JobTypeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface JobTypeAddRs {
  JobTypeRet?: JobTypeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface JobTypeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface JobTypeQueryRs {
  JobTypeRet: JobTypeRet[];
}

export interface JobTypeRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface JobTypeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz.In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
}

export interface JournalCreditLine {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information. */
  Memo?: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef?: EntityRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
}

export interface JournalDebitLine {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information. */
  Memo?: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef?: EntityRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
}

export interface JournalEntryAdd {
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** When a change is an “adjustment,” the original information is retained, usually so an accountant can see the effects of the adjustment. */
  IsAdjustment?: boolean;
  /** Indicates whether the transaction is using a home currency or foreign currency. */
  IsHomeCurrencyAdjustment?: boolean;
  /** Flag that indicates the amount being entered is in the home currency. */
  IsAmountsEnteredInHomeCurrency?: boolean;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If no amount is included in the first debit line (or credit line) of a journal entry in the QuickBooks user interface, then subsequent SDK queries on that `JournalEntry` object will fail XML validation. */
  JournalDebitLine?: JournalDebitLine | JournalDebitLine[];
  /** If no amount is included in the first credit line (or debit line) of a journal entry in the QuickBooks user interface, then subsequent SDK queries on that `JournalEntry` object will fail XML validation. */
  JournalCreditLine?: JournalCreditLine | JournalCreditLine[];
}

export interface JournalEntryAddRq {
  JournalEntryAdd: JournalEntryAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface JournalEntryAddRs {
  JournalEntryRet?: JournalEntryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface JournalEntryMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** When a change is an “adjustment,” the original information is retained, usually so an accountant can see the effects of the adjustment. */
  IsAdjustment?: boolean;
  /** Flag that indicates the amount being entered is in the home currency. */
  IsAmountsEnteredInHomeCurrency?: boolean;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** `IORJournalLineList` The list of journal lines in a `JournalMod` request – note that in a mod request, inclding one line means that you must include all lines, modified or not. */
  JournalLineMod?: JournalLineMod | JournalLineMod[];
}

export interface JournalEntryModRq {
  JournalEntryMod: JournalEntryMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface JournalEntryModRs {
  JournalEntryRet?: JournalEntryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface JournalEntryQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface JournalEntryQueryRs {
  JournalEntryRet: JournalEntryRet[];
}

export interface JournalEntryRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** When a change is an “adjustment,” the original information is retained, usually so an accountant can see the effects of the adjustment. */
  IsAdjustment?: boolean;
  /** Indicates whether the transaction is using a home currency or foreign currency. */
  IsHomeCurrencyAdjustment?: boolean;
  /** Flag that indicates the amount being entered is in the home currency. */
  IsAmountsEnteredInHomeCurrency?: boolean;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If no amount is included in the first debit line (or credit line) of a journal entry in the QuickBooks user interface, then subsequent SDK queries on that `JournalEntry` object will fail XML validation. */
  JournalDebitLine?: JournalDebitLine | JournalDebitLine[];
  /** If no amount is included in the first credit line (or debit line) of a journal entry in the QuickBooks user interface, then subsequent SDK queries on that `JournalEntry` object will fail XML validation. */
  JournalCreditLine?: JournalCreditLine | JournalCreditLine[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface JournalLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** The type of journal line (debit or credit). */
  JournalLineType?: JournalLineType;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information. */
  Memo?: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef?: EntityRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
}

export type JournalLineType = "Credit" | "Debit";

export type KeyEmployee = "No" | "Yes";

export interface LeadAdd {
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** The status of the lead. */
  Status?: Status;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** The main phone number. */
  MainPhone?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** List of locations. */
  Locations?: Locations | Locations[];
  /** List of lead contacts. */
  LeadContacts?: LeadContacts | LeadContacts[];
}

export interface LeadAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface LeadAddRq {
  LeadAdd: LeadAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface LeadAddRs {
  LeadRet?: LeadRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface LeadContacts {
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** Flag for if this is a primary contact on a lead. */
  IsPrimaryContact?: boolean;
}

export interface LeadContactsMod {
  /** `LeadContactID` is a way to identify a lead contact object. When a lead contact object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `LeadContactID`. */
  LeadContactID: number;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** Flag for if this is a primary contact on a lead. */
  IsPrimaryContact?: boolean;
}

export interface LeadContactsRet {
  /** `LeadContactID` is a way to identify a lead contact object. When a lead contact object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `LeadContactID`. */
  LeadContactID: number;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** Flag for if this is a primary contact on a lead. */
  IsPrimaryContact?: boolean;
}

export interface LeadMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** The status of the lead. */
  Status?: Status;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** The main phone number. */
  MainPhone?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** List of modified locations. */
  LocationsMod?: LocationsMod | LocationsMod[];
  /** List of modified lead contacts. */
  LeadContactsMod?: LeadContactsMod | LeadContactsMod[];
}

export interface LeadModRq {
  LeadMod: LeadMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface LeadModRs {
  LeadRet?: LeadRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface LeadQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** List of names. */
  Name?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface LeadQueryRs {
  LeadRet: LeadRet[];
}

export interface LeadRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** The status of the lead. */
  Status?: Status;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** The main phone number. */
  MainPhone?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** List of returned locations. */
  LocationsRet?: LocationsRet | LocationsRet[];
  /** List of returned lead contacts. */
  LeadContactsRet?: LeadContactsRet | LeadContactsRet[];
}

export interface LegalAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface LiabilityAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface LinkedTxn {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** The type of transaction. */
  TxnType: TxnType;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Indicates the nature of the link between the transactions: `ltAMTTYPE` means the two transactions are linked based on an amount value (for example `an` invoice linked to a payment). `ltQUANTYPE` means the two transactions are linked based on a quantity. This affects transactions that are linked to sales orders, estimates and purchase orders. For example, an invoice might be created from a sales order, based on the quantity of items received. */
  LinkType?: LinkType;
  /** A monetary amount. */
  Amount: string;
}

export interface LinkToTxn {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
}

export type LinkType = "AMTTYPE" | "QUANTYPE";

export interface Locations {
  /** Where the asset is located or has been placed into service. */
  Location: string;
  /** Address for the lead. */
  LeadAddress?: LeadAddress;
}

export interface LocationsMod {
  /** `LocationID` is a way to identify a location object. When a location object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `LocationID`. */
  LocationID: number;
  /** Where the asset is located or has been placed into service. */
  Location: string;
  /** Address for the lead. */
  LeadAddress?: LeadAddress;
}

export interface LocationsRet {
  /** `LocationID` is a way to identify a location object. When a location object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `LocationID`. */
  LocationID: number;
  /** Main address for the lead. */
  MainAddress: string;
  /** Where the asset is located or has been placed into service. */
  Location: string;
  /** Address for the lead. */
  LeadAddress?: LeadAddress;
}

export interface LotNumberAdjustment {
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Amount to adjust count. */
  CountAdjustment?: number;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
}

export type MatchCriterion = "Contains" | "EndsWith" | "StartsWith";

export type MilitaryStatus = "Active" | "Reserve";

export interface ModifiedDateRangeFilter {
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.

  For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).

  For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.

  For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).

  For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
}

export interface NameFilter {
  /** The criterion to match. */
  MatchCriterion: MatchCriterion;
  /** The string to match. */
  Name: string;
}

export interface NameRangeFilter {
  /** The first name or item in the search range. If `FromName` is omitted, the range will begin with first name on the list. */
  FromName?: string;
  /** The final name or item in the search range. If `ToName` is omitted, the range will end with last name on the list. */
  ToName?: string;
}

export type OnFile = "No" | "Yes";

export type Operator =
  | "Equal"
  | "GreaterThan"
  | "GreaterThanEqual"
  | "LessThan"
  | "LessThanEqual";

export type OptionForPriceRuleConflict = "BasePrice" | "Zero";

export interface OtherNameAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  OtherNameAddress?: OtherNameAddress;
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information. */
  Notes?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface OtherNameAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface OtherNameAddressBlock {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface OtherNameAddRq {
  OtherNameAdd: OtherNameAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface OtherNameAddRs {
  OtherNameRet?: OtherNameRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface OtherNameMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  OtherNameAddress?: OtherNameAddress;
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information. */
  Notes?: string;
}

export interface OtherNameModRq {
  OtherNameMod: OtherNameMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface OtherNameModRs {
  OtherNameRet?: OtherNameRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface OtherNameQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface OtherNameQueryRs {
  OtherNameRet: OtherNameRet[];
}

export interface OtherNameRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  OtherNameAddress?: OtherNameAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  OtherNameAddressBlock?: OtherNameAddressBlock;
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information. */
  Notes?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface OverrideClassRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface OverrideItemAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface OverrideUOMSetRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

/** @default: All */
export type PaidStatus = "All" | "NotPaidOnly" | "PaidOnly";

export interface ParentRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ParentSiteRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type PartOrFullTime = "FullTime" | "PartTime";

export interface PayeeEntityRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface PaymentMethodRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type PaymentStatus = "Completed" | "Unknown";

export type PayPeriod =
  | "Biweekly"
  | "Daily"
  | "Monthly"
  | "Quarterly"
  | "Semimonthly"
  | "Weekly"
  | "Yearly";

export interface PayrollDetailReportQueryRq {
  /** The type of report: `pdrtEmployeeStateTaxesDetail` lists state taxes withheld for `employeespdrtPayrollItemDetail` lists the payroll transactions on which each payroll item `appearspdrtPayrollReviewDetail` gives detailed information about how QuickBooks calculates tax amounts on employee paychecks and in year-to-date `transactionspdrtPayrollTransactionDetail` shows the line-item detail that appears on each payroll `transactionpdrtPayrollTransactionsByPayee` lists payroll transactions, grouping them by payee */
  PayrollDetailReportType: PayrollDetailReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeRowsBy` (along with `IncludeColumnList`, in most cases) determines what data is calculated for this report and controls how the rows are organized and labeled. For example, if you set the value to `srbAccount`, the report’s row labels might be “Checking,” “Savings,” and so on. */
  SummarizeRowsBy?: SummarizeRowsBy;
  /** A list of enum values showing which columns you want the report to return. (The report won’t return columns other than the ones you specify here.) */
  IncludeColumn?: IncludeColumn | IncludeColumn[];
  /** Indicates whether this report should include all accounts or just those that are currently in use. */
  IncludeAccounts?: IncludeAccounts;
  /** The report will return open balance information up to the `ReportOpenBalanceAsOf` date. */
  ReportOpenBalanceAsOf?: ReportOpenBalanceAsOf;
}

export interface PayrollDetailReportQueryRs {
  ReportRet: ReportRet[];
}

export type PayrollDetailReportType =
  | "EmployeeStateTaxesDetail"
  | "PayrollItemDetail"
  | "PayrollReviewDetail"
  | "PayrollTransactionDetail"
  | "PayrollTransactionsByPayee";

export interface PayrollItemWageAdd {
  /** Description of the wage: for example, Regular Pay or Overtime Pay. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The type of pay. */
  WageType: WageType;
  /** Refers to an expense account. If an `ExpenseAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ExpenseAccountRef: ExpenseAccountRef;
}

export interface PayrollItemWageAddRq {
  PayrollItemWageAdd: PayrollItemWageAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PayrollItemWageAddRs {
  PayrollItemWageRet?: PayrollItemWageRet;
}

export interface PayrollItemWageQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`.

  A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.

  For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).

  For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.

  For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).

  For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PayrollItemWageQueryRs {
  PayrollItemWageRet: PayrollItemWageRet[];
}

export interface PayrollItemWageRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface PayrollItemWageRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** Description of the wage: for example, Regular Pay or Overtime Pay. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The type of pay. */
  WageType: WageType;
  /** Refers to an expense account. If an `ExpenseAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ExpenseAccountRef: ExpenseAccountRef;
}

export interface PayrollSummaryReportQueryRq {
  /** The type of payroll report: `psrtEmployeeEarningsSummary` This report shows information similar to the payroll summary report, but in a different layout. The report has a row for each employee and a column for each payroll item. `psrtPayrollLiabilityBalances` This report lists the payroll liabilities the QuickBooks company owes to various agencies, such as the federal government, your state government, insurance plan administrators, labor unions, etc. The report covers unpaid liabilities incurred during the period of time shown in the From and To fields. If the company paid a liability incurred within the date range of the report, the report omits that liability, even if the payment occurred after the ending date of the report. `psrtPayrollSummary` This report shows the total wages, taxes withheld, deductions from net pay, additions to net pay, and employer-paid taxes and contributions for each employee on the payroll. */
  PayrollSummaryReportType: PayrollSummaryReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified account type or for specific list elements. */
  ReportAccountFilter?: ReportAccountFilter;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** Returns reports that were modified between these two dates (inclusive). The range of acceptable dates for both `FromReportModifiedDate` and `ToReportModifiedDate` is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ReportModifiedDateRangeFilter?: ReportModifiedDateRangeFilter;
  /** The time period covered by this report. */
  ReportModifiedDateRangeMacro?: ReportModifiedDateRangeMacro;
  /** The level of detail to include in the report. */
  ReportDetailLevelFilter?: ReportDetailLevelFilter;
  /** Allows you to query for posting reports, non-posting reports, or reports that are either one. */
  ReportPostingStatusFilter?: ReportPostingStatusFilter;
  /** `SummarizeColumnsBy` determines which data the report calculates and how the columns will be labeled across the top of the report. For example, if you set the value to `scbTwoWeek`, the report’s column labels might be “Feb 10-23, 02,” “Feb 24-Mar9, 02,” and so on. */
  SummarizeColumnsBy?: SummarizeColumnsBy;
  /** The default value is false, which means that the report will not include any subcolumn information. To include all available types of subcolumns for this report, set `IncludeSubcolumns` to true. The SDK will not return subcolumn information for data that can be easily computed. (For example, the SDK does not return the “percent of row” column.) */
  IncludeSubcolumns?: boolean;
  /** Specifies the type of year that will be used for this report. */
  ReportCalendar?: ReportCalendar;
  /** Specifies whether you want the report to include only rows with active information, only rows with nonzero values, or all rows regardless of their content or active status. */
  ReturnRows?: ReturnRows;
  /** Specifies whether you want the report to include only columns with active information, only columns with nonzero values, or all columns regardless of their content or active status. */
  ReturnColumns?: ReturnColumns;
}

export interface PayrollSummaryReportQueryRs {
  ReportRet: ReportRet[];
}

export type PayrollSummaryReportType =
  | "EmployeeEarningsSummary"
  | "PayrollLiabilityBalances"
  | "PayrollSummary";

/** @default: All */
export type PendingStatus = "All" | "NotPendingOnly" | "PendingOnly";

/** @default: None */
export type PreferredDeliveryMethod = "Email" | "Fax" | "None";

export interface PreferredPaymentMethodRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface PrefillAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface PrefVendorRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface PriceLevelAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** When you create a price level, you must specify whether it is a fixed percentage or a per item price level. Once you create the price level, you cannot change this. QuickBooks Pro and greater versions support fixed percentages, but only QuickBooks Premier and Enterprise support the per item price level. Where is this discount applied if `Price` Levels are enabled in QuickBooks preferences? The discount is applied to the sales price of the item. If the price level is applied to a customer, it automatically adjusts the `Rate` and `Amount` columns for applicable line items in a QuickBooks Sales Order form, Invoice form, etc. for that customer. The QuickBooks user could still select a different price level. However, the customer price level simply establishes a default price. If no price level is applied to the customer, then the QuickBooks user can apply a price level by clicking the dropdown list of price levels that appears next to the `Rate` column. The default in this case is simply the sales price established for the item. Notice that this value supports both positive and negative values. For example, a value of 20 would increase the price by 20% and value of -10 would decrease the price by 10%. */
  PriceLevelFixedPercentage?: string;
  /** When you create a price level, you must specify whether it is a fixed percentage or a per item price level. Once you create the price level, you cannot change this. Currently, only QuickBooks Premier and Enterprise support the per item price level. */
  PriceLevelPerItem?: PriceLevelPerItem | PriceLevelPerItem[];
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface PriceLevelAddRq {
  PriceLevelAdd: PriceLevelAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PriceLevelAddRs {
  PriceLevelRet?: PriceLevelRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface PriceLevelMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** When you create a price level, you must specify whether it is a fixed percentage or a per item price level. Once you create the price level, you cannot change this. QuickBooks Pro and greater versions support fixed percentages, but only QuickBooks Premier and Enterprise support the per item price level. Where is this discount applied if `Price` Levels are enabled in QuickBooks preferences? The discount is applied to the sales price of the item. If the price level is applied to a customer, it automatically adjusts the `Rate` and `Amount` columns for applicable line items in a QuickBooks Sales Order form, Invoice form, etc. for that customer. The QuickBooks user could still select a different price level. However, the customer price level simply establishes a default price. If no price level is applied to the customer, then the QuickBooks user can apply a price level by clicking the dropdown list of price levels that appears next to the `Rate` column. The default in this case is simply the sales price established for the item. Notice that this value supports both positive and negative values. For example, a value of 20 would increase the price by 20% and value of -10 would decrease the price by 10%. */
  PriceLevelFixedPercentage?: string;
  /** When you create a price level, you must specify whether it is a fixed percentage or a per item price level. Once you create the price level, you cannot change this. Currently, only QuickBooks Premier and Enterprise support the per item price level. */
  PriceLevelPerItem?: PriceLevelPerItem | PriceLevelPerItem[];
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface PriceLevelModRq {
  PriceLevelMod: PriceLevelMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PriceLevelModRs {
  PriceLevelRet?: PriceLevelRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface PriceLevelPerItem {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** When you create a price level, you have the option to create it with a custom price that is either a fixed amount (`CustomPrice`) or a fixed discount percentage (`CustomPricePercent`). Alternatively, instead of a flat custom price or discount, you could apply a price discount based on either the current custom price, the standard price of the item, or the cost of the item. */
  CustomPrice?: string;
  /** When you create a price level, you have the option to create it with a custom price that is either a fixed amount (`CustomPrice`) or a fixed discount percentage (`CustomPricePercent`). */
  CustomPricePercent?: string;
  /** If you don’t want to apply a custom price (for price levels) or custom rate (for billing rates), you can apply an adjusted price discount using the pair of fields `AdjustPercentage` and `AdjustRelativeTo` (`AdjustBillingRateRelativeTo` for billing rates). You specify the percentage discount or increase in the `AdjustPercentage` field and the price/rate to be discounted (standard item price, item cost, or the item’s current custom price) in the `AdjustRelativeTo` `fieldTo` field. Notice that this value supports both positive and negative values. For example, a value of 20 would increase the price by 20% and value of -10 would decrease the price by 10%. */
  AdjustPercentage: string;
  /** When you create a price level, you have the option to create it with a flat custom price (flat amount or percentage) or you could use `PriceLevelAdjustment` to apply a price discount based on either the current custom price, the standard price of the item, or the cost of the item. You specify the price discount in the `AdjustPercentage` field and the price to be discounted (standard item price, item cost, or the item’s current customer price) in the `AdjustRelativeTo` `fieldTo` field. */
  AdjustRelativeTo: AdjustRelativeTo;
}

export interface PriceLevelPerItemRet {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef: ItemRef;
  /** When you create a price level, you have the option to create it with a custom price that is either a fixed amount (`CustomPrice`) or a fixed discount percentage (`CustomPricePercent`). Alternatively, instead of a flat custom price or discount, you could apply a price discount based on either the current custom price, the standard price of the item, or the cost of the item. */
  CustomPrice?: string;
  /** When you create a price level, you have the option to create it with a custom price that is either a fixed amount (`CustomPrice`) or a fixed discount percentage (`CustomPricePercent`). */
  CustomPricePercent?: string;
}

export interface PriceLevelQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PriceLevelQueryRs {
  PriceLevelRet: PriceLevelRet[];
}

export interface PriceLevelRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface PriceLevelRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The types of price level, fixed percentage type or per item types. Per item types are only supported in Premier or Enterprise. */
  PriceLevelType?: PriceLevelType;
  /** When you create a price level, you must specify whether it is a fixed percentage or a per item price level. Once you create the price level, you cannot change this. QuickBooks Pro and greater versions support fixed percentages, but only QuickBooks Premier and Enterprise support the per item price level. Where is this discount applied if `Price` Levels are enabled in QuickBooks preferences? The discount is applied to the sales price of the item. If the price level is applied to a customer, it automatically adjusts the `Rate` and `Amount` columns for applicable line items in a QuickBooks Sales Order form, Invoice form, etc. for that customer. The QuickBooks user could still select a different price level. However, the customer price level simply establishes a default price. If no price level is applied to the customer, then the QuickBooks user can apply a price level by clicking the dropdown list of price levels that appears next to the `Rate` column. The default in this case is simply the sales price established for the item. Notice that this value supports both positive and negative values. For example, a value of 20 would increase the price by 20% and value of -10 would decrease the price by 10%. */
  PriceLevelFixedPercentage?: string;
  /** When you create a price level, you must specify whether it is a fixed percentage or a per item price level. Once you create the price level, you cannot change this. Currently, only QuickBooks Premier and Enterprise support the per item price level. */
  PriceLevelPerItemRet: PriceLevelPerItemRet | PriceLevelPerItemRet[];
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export type PriceLevelType = "FixedPercentage" | "PerItem";

export interface PrimaryContact {
  /** The name of the contact. */
  ContactName: string;
  /** The value of the contact field. */
  ContactValue: string;
  /** Relationship of emergency contact information to the employee. */
  Relation?: Relation;
}

export interface PurchaseOrderAdd {
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef?: VendorRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Refers to a customer, vendor, employee, or person on the “other names” list to whom this order is to be shipped. If a `ShipToEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipToEntityRef?: ShipToEntityRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** The date on which shipment is expected. */
  ExpectedDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** This can be included in reports, but it does not appear on the printed purchase order. */
  Memo?: string;
  /** Message to be printed on a purchase order for the vendor to read. */
  VendorMsg?: string;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** One line of the purchase order. Compare with `PurchaseOrderLineGroup`, which represents a previously defined group of lines in the purchase order. */
  PurchaseOrderLineAdd?: PurchaseOrderLineAdd | PurchaseOrderLineAdd[];
  /** Represents a previously defined group of lines in the purchase order. Compare with `PurchaseOrderLine`, which represents just one line in the purchase order. */
  PurchaseOrderLineGroupAdd?:
    | PurchaseOrderLineGroupAdd
    | PurchaseOrderLineGroupAdd[];
}

export interface PurchaseOrderAddRq {
  PurchaseOrderAdd: PurchaseOrderAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PurchaseOrderAddRs {
  PurchaseOrderRet?: PurchaseOrderRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface PurchaseOrderLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** Description that appears on the purchase order for this line item. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add or Mod request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface PurchaseOrderLineGroupAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface PurchaseOrderLineGroupMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `IPurchaseOrderLine` objects, each representing one line in this group of purchase order lines. */
  PurchaseOrderLineMod?: PurchaseOrderLineMod | PurchaseOrderLineMod[];
}

export interface PurchaseOrderLineGroupRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** Description that appears on the purchase order for this group line item. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup: boolean;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `IPurchaseOrderLine` objects, each representing one line in this group of purchase order lines. */
  PurchaseOrderLineRet?: PurchaseOrderLineRet | PurchaseOrderLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface PurchaseOrderLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** Description that appears on the purchase order for this line item. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add or Mod request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** If `IsManuallyClosed` is true, the purchase order line has been closed, even if this item has not been received or its sale cancelled. If all the purchase order lines are marked as closed, the purchase order itself is marked as closed as well. You cannot change `IsManuallyClosed` to false after the purchase order line has been fully received. */
  IsManuallyClosed?: boolean;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
}

export interface PurchaseOrderLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** The part number used by the manufacturer of the item. */
  ManufacturerPartNumber?: string;
  /** Description that appears on the purchase order for this line item. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add or Mod request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The quantity that has been received against this purchase order. */
  ReceivedQuantity?: number;
  /** The quantity that has not been billed. */
  UnbilledQuantity?: number;
  /** If `IsBilled` is true, the tracked time has already been billed. */
  IsBilled?: boolean;
  /** If `IsManuallyClosed` is true, the purchase order line has been closed, even if this item has not been received or its sale cancelled. If all the purchase order lines are marked as closed, the purchase order itself is marked as closed as well. You cannot change `IsManuallyClosed` to false after the purchase order line has been fully received. */
  IsManuallyClosed?: boolean;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface PurchaseOrderMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef?: VendorRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Refers to a customer, vendor, employee, or person on the “other names” list to whom this order is to be shipped. If a `ShipToEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipToEntityRef?: ShipToEntityRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** The date on which shipment is expected. */
  ExpectedDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** If `IsManuallyClosed` is true, this purchase order has been closed, even if all the items have not been received or the sale has not been cancelled. Once the purchase order is marked as closed, all the line items within it become closed as well. You cannot change `IsManuallyClosed` to false after the purchase order has been fully received. */
  IsManuallyClosed?: boolean;
  /** This can be included in reports, but it does not appear on the printed purchase order. */
  Memo?: string;
  /** Message to be printed on a purchase order for the vendor to read. */
  VendorMsg?: string;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** One line of the purchase order. Compare with `PurchaseOrderLineGroup`, which represents a previously defined group of lines in the purchase order. */
  PurchaseOrderLineMod?: PurchaseOrderLineMod;
  /** Represents a previously defined group of lines in the purchase order. Compare with `PurchaseOrderLine`, which represents just one line in the purchase order. */
  PurchaseOrderLineGroupMod?: PurchaseOrderLineGroupMod;
}

export interface PurchaseOrderModRq {
  PurchaseOrderMod: PurchaseOrderMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface PurchaseOrderModRs {
  PurchaseOrderRet?: PurchaseOrderRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface PurchaseOrderQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface PurchaseOrderQueryRs {
  PurchaseOrderRet: PurchaseOrderRet[];
}

export interface PurchaseOrderRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef?: VendorRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Refers to a customer, vendor, employee, or person on the “other names” list to whom this order is to be shipped. If a `ShipToEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipToEntityRef?: ShipToEntityRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  VendorAddressBlock?: VendorAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** The date on which shipment is expected. */
  ExpectedDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The returned `TotalAmount` will be the total of the amounts in the purchase order lines and group lines. */
  TotalAmount?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Total amount of money paid or received in the home currency. */
  TotalAmountInHomeCurrency?: string;
  /** If `IsManuallyClosed` is true, this purchase order has been closed, even if all the items have not been received or the sale has not been cancelled. Once the purchase order is marked as closed, all the line items within it become closed as well. You cannot change `IsManuallyClosed` to false after the purchase order has been fully received. */
  IsManuallyClosed?: boolean;
  /** If `IsFullyReceived` is true, all the items in the purchase order have been received and none of them was closed manually. */
  IsFullyReceived?: boolean;
  /** This can be included in reports, but it does not appear on the printed purchase order. */
  Memo?: string;
  /** Message to be printed on a purchase order for the vendor to read. */
  VendorMsg?: string;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty. The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** One line of the purchase order. Compare with `PurchaseOrderLineGroup`, which represents a previously defined group of lines in the purchase order. */
  PurchaseOrderLineRet?: PurchaseOrderLineRet;
  /** Represents a previously defined group of lines in the purchase order. Compare with `PurchaseOrderLine`, which represents just one line in the purchase order. */
  PurchaseOrderLineGroupRet?: PurchaseOrderLineGroupRet;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface PurchaseTaxCodeRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface QuantityAdjustment {
  /** The new quantity for this inventory item. */
  NewQuantity?: number;
  /** Either a positive or negative number that shows the change in quantity for this inventory item. */
  QuantityDifference?: number;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
}

export interface RateEntry {
  /** Indicates the price of something. */
  Rate: string;
  /** Specifies the date at which the workers’ comp code and it’s related premium goes into effect. */
  EffectiveDate: string;
}

export interface RateHistory {
  /** Indicates the price of something. */
  Rate: string;
  /** Specifies the date at which the workers’ comp code and it’s related premium goes into effect. */
  EffectiveDate: string;
}

export interface ReceivePaymentAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Total amount of money received. For `ReceivePaymentAdd`, the sum of the `PaymentAmount` amounts (in the `AppliedToTxnAdd` aggregates that are included) cannot be greater than the `TotalAmount`, or you will receive an error. */
  TotalAmount?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** The beginning of this memo will appear in reports that show details of this receive payment. */
  Memo?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If `IsAutoApply` is true, QuickBooks applies `TotalAmount` to any outstanding transaction that exactly matches `TotalAmount`. If no exact match is found, the payment is applied to the customer job’s outstanding transactions, beginning with the oldest one.If `IsAutoApply` is false, QuickBooks receives the payment but does not apply it to any outstanding transaction. Instead, the amount will appear as a credit on the customer job’s next transaction. */
  IsAutoApply?: boolean;
  /** `AppliedToTxn` List A list of `AppliedToTxn` aggregates. */
  AppliedToTxnAdd?: AppliedToTxnAdd | AppliedToTxnAdd[];
}

export interface ReceivePaymentAddRq {
  ReceivePaymentAdd: ReceivePaymentAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ReceivePaymentAddRs {
  ReceivePaymentRet?: ReceivePaymentRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ReceivePaymentMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Total amount of money received. For `ReceivePaymentAdd`, the sum of the `PaymentAmount` amounts (in the `AppliedToTxnAdd` aggregates that are included) cannot be greater than the `TotalAmount`, or you will receive an error. */
  TotalAmount?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** The beginning of this memo will appear in reports that show details of this receive payment. */
  Memo?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfoMod?: CreditCardTxnInfoMod;
  /** `AppliedToTxn` List

  A list of `AppliedToTxn` aggregates. */
  AppliedToTxnMod?: AppliedToTxnMod | AppliedToTxnMod[];
}

export interface ReceivePaymentModRq {
  ReceivePaymentMod: ReceivePaymentMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface ReceivePaymentModRs {
  ReceivePaymentRet?: ReceivePaymentRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface ReceivePaymentQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface ReceivePaymentQueryRs {
  ReceivePaymentRet: ReceivePaymentRet[];
}

export interface ReceivePaymentRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note: In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited. In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Refers to an accounts receivable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsReceivable`.) If an `ARAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  If this field is in a transaction that links to other transactions, make sure this `ARAccountRef` matches the `ARAccountRef` used in the other transactions. For example, in an `ARRefundCreditCard` transaction, the `ARAccountRef` of the credit card refund transaction must match the `ARAccountRef` used in each of the linked credit transactions. */
  ARAccountRef?: ARAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Total amount of money received. For `ReceivePaymentAdd`, the sum of the `PaymentAmount` amounts (in the `AppliedToTxnAdd` aggregates that are included) cannot be greater than the `TotalAmount`, or you will receive an error. */
  TotalAmount?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Total amount of money paid or received in the home currency. */
  TotalAmountInHomeCurrency?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** The beginning of this memo will appear in reports that show details of this receive payment. */
  Memo?: string;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** `ReceivePaymentRet` will include an unused payment in cases such as these: The sum of the `PaymentAmount` amounts is less than `TotalAmount`. A payment is received for the exact amount of an invoice, but a credit or a discount (or both) are set. */
  UnusedPayment?: string;
  /** `ReceivePaymentRet` will include an unused credit if the `AppliedAmount` of a `SetCredit` aggregate is less than the amount of credit available for the specified `CreditTxnID`. */
  UnusedCredits?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** `AppliedToTxn` List

  A list of `AppliedToTxn` aggregates. */
  AppliedToTxnRet?: AppliedToTxnRet | AppliedToTxnRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface RefNumberFilter {
  /** The criterion to match. */
  MatchCriterion: MatchCriterion;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber: string;
}

export interface RefNumberRangeFilter {
  /** The first `RefNumber` in the search range. If `FromRefNumber` is omitted, the range will begin with first number on the list. */
  FromRefNumber?: string;
  /** The final `RefNumber` in the search range. If `ToRefNumber` is omitted, the range will end with last number on the list. */
  ToRefNumber?: string;
}

export type Relation =
  | "Brother"
  | "Daughter"
  | "Father"
  | "Friend"
  | "Mother"
  | "Other"
  | "Partner"
  | "Sister"
  | "Son"
  | "Spouse";

export interface ReportAccountFilter {
  /** Allows you to report on a specific account type. */
  AccountTypeFilter?: AccountTypeFilter;
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

/** @default: None */
export type ReportBasis = "Accrual" | "Cash" | "None";

export type ReportCalendar = "CalendarYear" | "FiscalYear" | "TaxYear";

export interface ReportClassFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

export interface ReportData {
  /** A data row contains the actual data for each column. */
  DataRow?: DataRow | DataRow[];
  /** A text row contains only text and is used mainly for headings. */
  TextRow?: TextRow | TextRow[];
  /** A row that contains a calculated subtotal of the data in all the rows since the last `SubTotalRow` and, usually, a single underline. There can be multiple `SubTotalRow` aggregates in a report. */
  SubtotalRow?: SubtotalRow | SubtotalRow[];
  /** A row that contains a calculated total of all the data that has come before and a double underline. There will only be one `TotalRow` per report. If `TotalRow` does not include any numerical values, the columns required to show the total values are not part of the report. These columns were not included when the report was customized. */
  TotalRow?: TotalRow;
}

export type ReportDateMacro =
  | "All"
  | "LastMonth"
  | "LastMonthToDate"
  | "LastQuarter"
  | "LastQuarterToDate"
  | "LastWeek"
  | "LastWeekToDate"
  | "LastYear"
  | "LastYearToDate"
  | "NextFourWeeks"
  | "NextMonth"
  | "NextQuarter"
  | "NextWeek"
  | "NextYear"
  | "ThisMonth"
  | "ThisMonthToDate"
  | "ThisQuarter"
  | "ThisQuarterToDate"
  | "ThisWeek"
  | "ThisWeekToDate"
  | "ThisYear"
  | "ThisYearToDate"
  | "Today"
  | "Yesterday";

/** @default: All */
export type ReportDetailLevelFilter =
  | "All"
  | "AllExceptSummary"
  | "SummaryOnly";

export interface ReportEntityFilter {
  /** Allows you to report on a specific name type. */
  EntityTypeFilter?: EntityTypeFilter;
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

/** @default: Quarterly */
export type ReportingPeriod = "Monthly" | "Quarterly";

export interface ReportItemFilter {
  /** Allows you to report on a specific item type. */
  ItemTypeFilter?: ItemTypeFilter;
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Allows you to filter for data that relates to the specified object and its descendants. */
  ListIDWithChildren?: string;
  /** Allows you to filter for data that relates to the specified object and its descendants. For names that do not have children, `FullNameWithChildren` is exactly the same as `FullName`. */
  FullNameWithChildren?: string;
}

export interface ReportModifiedDateRangeFilter {
  /** Selects information from this date and later. The range of acceptable dates is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  FromReportModifiedDate?: string;
  /** Selects information created on this date or earlier. The range of acceptable dates is 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ToReportModifiedDate?: string;
}

export type ReportModifiedDateRangeMacro =
  | "All"
  | "LastMonth"
  | "LastMonthToDate"
  | "LastQuarter"
  | "LastQuarterToDate"
  | "LastWeek"
  | "LastWeekToDate"
  | "LastYear"
  | "LastYearToDate"
  | "NextFourWeeks"
  | "NextMonth"
  | "NextQuarter"
  | "NextWeek"
  | "NextYear"
  | "ThisMonth"
  | "ThisMonthToDate"
  | "ThisQuarter"
  | "ThisQuarterToDate"
  | "ThisWeek"
  | "ThisWeekToDate"
  | "ThisYear"
  | "ThisYearToDate"
  | "Today"
  | "Yesterday";

/** @default: Today */
export type ReportOpenBalanceAsOf = "ReportEndDate" | "Today";

export interface ReportPeriod {
  /** Selects information from this date and later. The range of acceptable `FromReportDate` and `ToReportDate` values depends on how the report dates are determined. If the report dates are based on the dates of transactions, the range is 01/01/1901 to 12/31/9999. If the report dates are based on modification dates, the range will be 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). If you omit `FromReportDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST). */
  FromReportDate?: string;
  /** Selects information created on this date or earlier. The range of acceptable `ToReportDate` and `FromReportDate` values depends on how the report dates are determined. If the report dates are based on the dates of transactions, the range is 01/01/1901 to 12/31/9999. If the report dates are based on modification dates, the range will be 1970-01-01 to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). If you omit `ToReportDate`, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). */
  ToReportDate?: string;
}

export type ReportPostingStatusFilter = "Either" | "NonPosting" | "Posting";

export interface ReportRet {
  /** The main title for this report. */
  ReportTitle: string;
  /** The subtitle for this report. */
  ReportSubtitle: string;
  /** If `ReportBasis` is `rbCash`, the report bases income and expenses on the dates when money changed hands.`rbAccrual`, the report bases income on the dates when customers were invoiced and bases expenses on the dates when bills were entered.`rbNone`, the report uses the default `ReportBasis`, which is either the QuickBooks Preference setting or the QuickBooks default for a given type of report. In a report response, the SDK returns `rbNone` for reports that do not support `ReportBasis`. (The 1099 report, for example, has its own basis for generation.) */
  ReportBasis?: ReportBasis;
  /** The number of rows in the report. */
  NumRows: number;
  /** The number of columns in the report. */
  NumColumns: number;
  /** The number of rows to allocate for column titles. Although this number is usually 1, with some reports it is 2 or 3. (For an example of column titles that span multiple rows, look at a `ProfitAndLossByJob` report in QuickBooks.) */
  NumColTitleRows: number;
  /** A list of `IColDesc` objects, each of which identifies one column in the report. Each column is identified by a `colID` (the position of the column in the report), a title, and a type. If the report contains any data, it is given row-by-row in an `IReportData` object. */
  ColDesc: ColDesc | ColDesc[];
  /** If the report contains any data, it is given row-by-row in a `ReportData` aggregate. */
  ReportData?: ReportData;
}

export interface ReportTxnTypeFilter {
  /** A list of the transaction types you want the report to cover. */
  TxnTypeFilter: TxnTypeFilter | TxnTypeFilter[];
}

export type ReturnColumns = "ActiveOnly" | "All" | "NonZero";

export type ReturnRows = "ActiveOnly" | "All" | "NonZero";

export interface RowData {
  /** An enumerated value that shows the type of data that this row contains. Values: account class customer `customerMessage` `customerType` employee item `jobType` label `memorizedTxn` `memorizedReport` name `otherName` `paymentMethod` `payrollItem` `salesRep` `salesTaxCode` `shipMethod` state style terms `toDo` vendor `vendorType` */
  RowType: RowType;
  /** The data in this cell of the report. */
  Value: string;
}

export type RowType =
  | "account"
  | "class"
  | "customer"
  | "customerMessage"
  | "customerType"
  | "employee"
  | "item"
  | "jobType"
  | "label"
  | "memorizedReport"
  | "memorizedTxn"
  | "name"
  | "otherName"
  | "paymentMethod"
  | "payrollItem"
  | "salesRep"
  | "salesTaxCode"
  | "shipMethod"
  | "state"
  | "style"
  | "terms"
  | "toDo"
  | "vendor"
  | "vendorType";

export interface SalesAndPurchase {
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to an expense account. If an `ExpenseAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ExpenseAccountRef?: ExpenseAccountRef;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
}

export interface SalesAndPurchaseMod {
  /** Appears in the `Description` column of a sales form when the QuickBooks user sells this item. For a fixed asset, describes the sale of the asset (for accounting purposes). */
  SalesDesc?: string;
  /** Price charged for this item. */
  SalesPrice?: string;
  /** Refers to an income account. If an `IncomeAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  IncomeAccountRef?: IncomeAccountRef;
  /** Used to support changing the `AccountRef` in the Mod request. When you do this, the QuickBooks UI normally displays a prompt asking whether the change should apply to existing transactions or not. Specifying False basically dismisses this with a “No” answer; specifying True dismisses it with a “Yes” answer and then changes the existing transactions that use the item with that `AccountRef`. Setting this to “True” should be used with caution and normally only after some user has indicated that they want those changes made to all those existing transactions! If any affected transactions are protected by a closing date and password, the `AccountRef` changes will not be made and so the Mod request will return an error without making the requested Mod. */
  ApplyIncomeAccountRefToExistingTxns?: boolean;
  /** Description that appears in the `Description` column of checks, bills, credit card charges, and item receipts (when an item is reordered). For a fixed asset, a description of the item as it was when it was purchased. */
  PurchaseDesc?: string;
  /** Amount that the QuickBooks user expects to pay when ordering or buying this item, or the amount that was actually paid for this item. */
  PurchaseCost?: string;
  /** Account used for taxes on purchases in CA or UK. */
  PurchaseTaxCodeRef?: PurchaseTaxCodeRef;
  /** Refers to an expense account. If an `ExpenseAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ExpenseAccountRef?: ExpenseAccountRef;
  /** Used to support changing the `AccountRef` in the Mod request. When you do this, the QuickBooks UI normally displays a prompt asking whether the change should apply to existing transactions or not. Specifying False basically dismisses this with a “No” answer; specifying True dismisses it with a “Yes” answer and then changes the existing transactions that use the item with that `AccountRef`. Setting this to “True” should be used with caution and normally only after some user has indicated that they want those changes made to all those existing transactions! If any affected transactions are protected by a closing date and password, the `AccountRef` changes will not be made and so the Mod request will return an error without making the requested Mod. */
  ApplyExpenseAccountRefToExistingTxns?: boolean;
  /** The preferred vendor for this item. If a `PrefVendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  PrefVendorRef?: PrefVendorRef;
}

export interface SalesOrderAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** If `IsManuallyClosed` is true, this sales order has been closed, even if some line items within it have not been invoiced. */
  IsManuallyClosed?: boolean;
  /** Additional information. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** Represents one line in the sales order. Compare with `SalesOrderLineGroup`, which represents a previously defined group of lines in the sales order. */
  SalesOrderLineAdd?: SalesOrderLineAdd | SalesOrderLineAdd[];
  /** Represents a previously defined group of lines in the sales order. Compare with `SalesOrderLine`, which represents just one line in the sales order. */
  SalesOrderLineGroupAdd?: SalesOrderLineGroupAdd | SalesOrderLineGroupAdd[];
  /** The Sales Channel `Name` */
  SOChannel?: SOChannel;
  /** The Sales Store `Name` */
  StoreName?: string;
  /** The Sales Store type */
  StoreType?: string;
}

export interface SalesOrderAddRq {
  SalesOrderAdd: SalesOrderAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesOrderAddRs {
  SalesOrderRet?: SalesOrderRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesOrderLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** If `IsManuallyClosed` is true, this line of the sales order has been closed even if it has not been invoiced. */
  IsManuallyClosed?: boolean;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface SalesOrderLineGroupAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface SalesOrderLineGroupMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `SalesOrderLineRet` objects, each representing one line in the sales order. */
  SalesOrderLineMod?: SalesOrderLineMod | SalesOrderLineMod[];
}

export interface SalesOrderLineGroupRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup: boolean;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `SalesOrderLineRet` objects, each representing one line in the sales order. */
  SalesOrderLineRet?: SalesOrderLineRet | SalesOrderLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
  /** The Sales Channel `Name`. */
  SOChannel?: SOChannel;
  /** The Sales Store `Name`. */
  StoreName?: string;
  /** The Sales Store type. */
  StoreType?: string;
}

export interface SalesOrderLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** If `IsManuallyClosed` is true, this line of the sales order has been closed even if it has not been invoiced. */
  IsManuallyClosed?: boolean;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
}

export interface SalesOrderLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The amount of this sales order line that has been invoiced. */
  Invoiced?: number;
  /** If `IsManuallyClosed` is true, this line of the sales order has been closed even if it has not been invoiced. */
  IsManuallyClosed?: boolean;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface SalesOrderMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** If `IsManuallyClosed` is true, this sales order has been closed, even if some line items within it have not been invoiced. */
  IsManuallyClosed?: boolean;
  /** Additional information. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Represents one line in the sales order. Compare with `SalesOrderLineGroup`, which represents a previously defined group of lines in the sales order. */
  SalesOrderLineMod?: SalesOrderLineMod;
  /** Represents a previously defined group of lines in the sales order. Compare with `SalesOrderLine`, which represents just one line in the sales order. */
  SalesOrderLineGroupMod?: SalesOrderLineGroupMod;
  /** The Sales Channel `Name`. */
  SOChannel?: SOChannel;
  /** The Sales Store `Name`. */
  StoreName?: string;
  /** The Sales Store type. */
  StoreType?: string;
}

export interface SalesOrderModRq {
  SalesOrderMod: SalesOrderMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesOrderModRs {
  SalesOrderRet?: SalesOrderRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesOrderQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface SalesOrderQueryRs {
  SalesOrderRet: SalesOrderRet[];
}

export interface SalesOrderRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  BillAddressBlock?: BillAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** Purchase order number. */
  PONumber?: string;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** The date on which payment is due. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** The total of the amounts in all the lines of an invoice, estimate, sales receipt, or credit memo before taxes or payments are applied. (By contrast, a subtotal item (an `ItemSubtotal` object) gives only the total of the amounts in the lines that appear above it.) */
  Subtotal?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The percentage charged for sales tax. */
  SalesTaxPercentage?: string;
  /** The total amount of sales tax charged. */
  SalesTaxTotal?: string;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Total amount of money paid or received in the home currency. */
  TotalAmountInHomeCurrency?: string;
  /** If `IsManuallyClosed` is true, this sales order has been closed, even if some line items within it have not been invoiced. */
  IsManuallyClosed?: boolean;
  /** If `IsFullyInvoiced` is true, all the items in the sales order have been invoiced. */
  IsFullyInvoiced?: boolean;
  /** Additional information. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty. The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** Represents one line in the sales order. Compare with `SalesOrderLineGroup`, which represents a previously defined group of lines in the sales order. */
  SalesOrderLineRet?: SalesOrderLineRet;
  /** Represents a previously defined group of lines in the sales order. Compare with `SalesOrderLine`, which represents just one line in the sales order. */
  SalesOrderLineGroupRet?: SalesOrderLineGroupRet;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface SalesOrPurchase {
  /** A descriptive text field. */
  Desc?: string;
  /** The purchase price or sales price of this item. */
  Price?: string;
  /** The price expressed as a percent. (For example, an auto shop that calculates the cost of labor as a percentage of the cost of parts might have a service item called “Labor” that uses `PricePercent` instead of `Price`.) */
  PricePercent?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
}

export interface SalesOrPurchaseMod {
  /** A descriptive text field. */
  Desc?: string;
  /** The purchase price or sales price of this item. */
  Price?: string;
  /** The price expressed as a percent. (For example, an auto shop that calculates the cost of labor as a percentage of the cost of parts might have a service item called “Labor” that uses `PricePercent` instead of `Price`.) */
  PricePercent?: string;
  /** The Account list is the company file’s list of accounts. An `AccountRef` aggregate refers to one of these accounts. (If an `AccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.) Special cases to note:In a Check message, `AccountRef` refers to the account from which the funds are being drawn for this check, for example, Checking or Savings.In an `ExpenseLineAdd` message, you must include `AccountRef` if the “Require accounts” check box is selected in the QuickBooks Accounting preferences. (It is selected by default.) In a `CreditCardCredit` message, `AccountRef` refers to the bank account or credit card account to which the credit is applied.In a `CreditCardCharge` message, `AccountRef` refers to the bank or credit card company to whom money is owed. How do you increase and decrease amounts in bank accounts? The following requests increase the balance in a bank account: Deposit Add `ReceivePaymentAdd` Journal Entry Add Sales `ReceiptAdd` The following requests decrease the balance in a bank account: `CheckAdd` Bill `PaymentCheckAdd` `JournalEntryAdd` */
  AccountRef?: AccountRef;
  /** Used to support changing the `AccountRef` in the Mod request. When you do this, the QuickBooks UI normally displays a prompt asking whether the change should apply to existing transactions or not. Specifying False basically dismisses this with a “No” answer; specifying True dismisses it with a “Yes” answer and then changes the existing transactions that use the item with that `AccountRef`. Setting this to “True” should be used with caution and normally only after some user has indicated that they want those changes made to all those existing transactions! If any affected transactions are protected by a closing date and password, the `AccountRef` changes will not be made and so the Mod request will return an error without making the requested Mod. */
  ApplyAccountRefToExistingTxns?: boolean;
}

export interface SalesReceiptAdd {
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the sales receipt. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsPending` is set to true, the sales receipt has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. */
  IsPending?: boolean;
  /** The check number of a check that a QuickBooks user writes or receives from someone else. */
  CheckNumber?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** A sales receipt does not ordinarily include a due date, because sales receipts are generally used for point-of-sale payments, where full payment is received at the time of purchase. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Message that appears in reports, but not on the sales receipt. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** One line of the sales receipt. Compare with `SalesReceiptLineGroup`, which represents a previously defined group of lines in the sales receipt. */
  SalesReceiptLineAdd?: SalesReceiptLineAdd | SalesReceiptLineAdd[];
  /** Represents a previously defined group of lines in the sales receipt. Compare with `SalesReceiptLine`, which represents just one line in the sales receipt. */
  SalesReceiptLineGroupAdd?:
    | SalesReceiptLineGroupAdd
    | SalesReceiptLineGroupAdd[];
}

export interface SalesReceiptAddRq {
  SalesReceiptAdd: SalesReceiptAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesReceiptAddRs {
  SalesReceiptRet?: SalesReceiptRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesReceiptLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface SalesReceiptLineGroupAdd {
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExt?: DataExt | DataExt[];
}

export interface SalesReceiptLineGroupMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef?: ItemGroupRef;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** A list of `ISalesReceiptLineRet` objects, each representing one line in the sales receipt. */
  SalesReceiptLineMod?: SalesReceiptLineMod | SalesReceiptLineMod[];
}

export interface SalesReceiptLineGroupRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** `ItemGroup` objects represent items that are grouped together for fast entry, and an `ItemGroupRef` aggregate refers to one of these item groups. In a request, if an `ItemGroupRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. You can use an `ItemGroupQuery` request to get information about all the item groups that are set up in the QuickBooks file. */
  ItemGroupRef: ItemGroupRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If true, a list of this group’s individual items their amounts will appear on printed forms. */
  IsPrintItemsInGroup: boolean;
  /** Total amount of money paid or received. In a receive payment add transaction that has payment amount elements (such as `AppliedToTxnAdd` lines) you must supply a `TotalAmount` and the sum of all the `PaymentAmount` elements must not be greater than the `TotalAmount`. */
  TotalAmount: string;
  /** A list of `ISalesReceiptLineRet` objects, each representing one line in the sales receipt. */
  SalesReceiptLineRet?: SalesReceiptLineRet | SalesReceiptLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface SalesReceiptLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** You can use price levels to specify custom pricing for specific customers. Once you create a price level for a customer, QuickBooks will automatically use the custom price in new invoices, sales receipts, sales orders or credit memos for that customer. You can override this automatic feature, however, when you create the invoices, sales receipts, etc.) The user can now specify a price level on line items in the following supported sales transactions: invoices, sales receipts, credit memos, and sales orders. Notice that the response data for the affected sales transaction does not list the price level that was used. The response simply lists the `Rate` for the item, which was set using the price level. */
  PriceLevelRef?: PriceLevelRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Flag to override price rule conflict. */
  OptionForPriceRuleConflict?: OptionForPriceRuleConflict;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Refers to a QuickBooks account. If you are using QB Online edition, you cannot specify an accounts receivable account here. If an `OverrideItemAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  OverrideItemAccountRef?: OverrideItemAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
}

export interface SalesReceiptLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** A descriptive text field. */
  Desc?: string;
  /** `QuantityFor` transactions: If an item line add on a transaction request specifies `Quantity` and `Amount` but not `Rate`, QuickBooks will use `Quantity` and `Amount` to calculate `Rate`. Likewise, if a request specifies `Quantity` and `Rate` but not `Amount`, QuickBooks will calculate the `Amount`. If a transaction add request includes a reference to an `ItemDiscount` item, do not include a `Quantity` element as well, or you will get an error. For Item requests: `Quantity` indicates how many of this item there are. */
  Quantity?: number;
  /** In a transaction line item, the name of the unit of measure selected from within the item’s available units. If the company file is enabled only for single unit of measure per item, this must be the base unit! */
  UnitOfMeasure?: string;
  /** When you modify a transaction line to change the unit of measure used in that line, you use this aggregate to specify the UOM set within which you are choosing an available unit of measure. The “override” here refers to the unit within the set, not the UOM Set itself, which you cannot change or override–the UOM set that can be set or changed only in the item itself via an Item Mod request. */
  OverrideUOMSetRef?: OverrideUOMSetRef;
  /** If you specify both `Rate` and `Amount` in a request, the `Rate` you provide will be ignored, and you will receive a warning. If you specify both `Quantity` and `Amount` in an Add request, QuickBooks will use them to calculate `Rate`. (Rate, `Amount`, and `Quantity` cannot be cleared.) */
  Rate?: string;
  /** Indicates the price of something as a percent. */
  RatePercent?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Site where inventory is located. */
  InventorySiteRef?: InventorySiteRef;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Indicates the date on which the QuickBooks user performs the service for the customer. */
  ServiceDate?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other1?: string;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other2?: string;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface SalesReceiptMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the sales receipt. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** If `IsPending` is set to true, the sales receipt has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. */
  IsPending?: boolean;
  /** The check number of a check that a QuickBooks user writes or receives from someone else. */
  CheckNumber?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** A sales receipt does not ordinarily include a due date, because sales receipts are generally used for point-of-sale payments, where full payment is received at the time of purchase. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** Message that appears in reports, but not on the sales receipt. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** One line of the sales receipt. Compare with `SalesReceiptLineGroup`, which represents a previously defined group of lines in the sales receipt. */
  SalesReceiptLineMod?: SalesReceiptLineMod;
  /** Represents a previously defined group of lines in the sales receipt. Compare with `SalesReceiptLine`, which represents just one line in the sales receipt. */
  SalesReceiptLineGroupMod?: SalesReceiptLineGroupMod;
}

export interface SalesReceiptModRq {
  SalesReceiptMod: SalesReceiptMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesReceiptModRs {
  SalesReceiptRet?: SalesReceiptRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesReceiptQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface SalesReceiptQueryRs {
  SalesReceiptRet: SalesReceiptRet[];
}

export interface SalesReceiptRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** QuickBooks templates specify how to print certain transactions. A template query returns the names of all templates that have been defined in QuickBooks. A `TemplateRef` element refers to one of these templates. */
  TemplateRef?: TemplateRef;
  /** The date of the sales receipt. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  BillAddress?: BillAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  BillAddressBlock?: BillAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  ShipAddressBlock?: ShipAddressBlock;
  /** If `IsPending` is set to true, the sales receipt has not been completed. Pending sales might include unpaid orders, estimates, tracked hours that have not yet been billed, or sales of back-ordered items. */
  IsPending?: boolean;
  /** The check number of a check that a QuickBooks user writes or receives from someone else. */
  CheckNumber?: string;
  /** A customer’s payment method, for example, cash, check, or Master Card. A `PaymentMethodRef` aggregate refers to an item on the `PaymentMethod` list. In a request, if a `PaymentMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `SalesReceiptAdd`, `ReceivePaymentAdd`, or `ARRefundCreditCard` request that contains credit card transaction data supplied from QBMS transaction responses, you must specify the payment method, and the payment method must be a credit card type. */
  PaymentMethodRef?: PaymentMethodRef;
  /** A sales receipt does not ordinarily include a due date, because sales receipts are generally used for point-of-sale payments, where full payment is received at the time of purchase. */
  DueDate?: string;
  /** A sales representative must be on the Employee, Vendor, or `Other` Names list within QuickBooks. Sales representative’s names and initials appear on the Rep drop-down list on QuickBooks sales forms. A `SalesRepRef` refers to a person on the `SalesRep` list. In a request, if a `SalesRepRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  SalesRepRef?: SalesRepRef;
  /** The date when the product was, or will be, shipped. */
  ShipDate?: string;
  /** A shipping method, for example, standard mail or overnight delivery. A `ShipMethodRef` aggregate refers to an item on the `ShipMethod` list. In a request, if a `ShipMethodRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ShipMethodRef?: ShipMethodRef;
  /** QuickBooks uses the term `FOB`, “freight on board,” to indicate the place from which the product is shipped. The `FOB` has no accounting implications. */
  FOB?: string;
  /** The total of all the sales-receipt lines before taxes are applied. (By contrast, a subtotal item (an `ItemSubtotal` object) gives only the total of the amounts in the lines that appear above it.) */
  Subtotal?: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** The percentage charged for sales tax. */
  SalesTaxPercentage?: string;
  /** The total amount of sales tax charged. */
  SalesTaxTotal?: string;
  /** Subtotal plus `SalesTaxTotal`. */
  TotalAmount?: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Total amount of money paid or received in the home currency. */
  TotalAmountInHomeCurrency?: string;
  /** Message that appears in reports, but not on the sales receipt. */
  Memo?: string;
  /** A standard message such as “Thank you for your business,” or “Please sign and return this estimate to indicate your approval.” A customer message can be included at the bottom of a form. A `CustomerMsgRef` aggregate refers to one of the messages on the `CustomerMsg` list. In a request, if a `CustomerMsgRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerMsgRef?: CustomerMsgRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** If this is set to true, at runtime the customer referenced in this transaction will be checked for a valid email address. If there is no valid email address, the request will fail. If there is a valid email address currently in QuickBooks for the customer, and the request succeeds, the transaction will be added to `QuickBook`’s list of forms to be emailed, possibly in a batch. Notice that setting this field to true does not actually perform the emailing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from emailing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be emailed. */
  IsToBeEmailed?: boolean;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Refers to the sales-tax code for sales related to this customer. (That is, it refers to a member of the `SalesTaxCode` list.) The sales-tax code indicates whether an item is taxable or non-taxable, and why. In a request, if a `CustomerSalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  CustomerSalesTaxCodeRef?: CustomerSalesTaxCodeRef;
  /** Refers to the account where these funds will be (or have been) deposited. In a `ReceivePaymentAdd` request, the default is Undeposited Funds if this is not included in the request. In a request, if a `DepositToAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  DepositToAccountRef?: DepositToAccountRef;
  /** Contains data from the credit card transaction used in the payment. This data originates from a previous `qbmsXML` credit card transaction. The data following the element `CreditCardTxnInputInfo`” data is the data from the original `qbmsXML` request. The “`CreditCardTxnResultInfo`” is the data from the original `qbmsXML` response. */
  CreditCardTxnInfo?: CreditCardTxnInfo;
  /** Other, `Other1`, and `Other2` are standard QuickBooks custom fields available to transactions. The `Other` field is a transaction-level field, like the `FOB` field, PO Number field, and so forth. This field appears only once for the transaction: you can write to it and modify it. The `Other1` and `Other2` fields exist at the line item level; each line item has them, and you can write or modify the value in each line. These custom fields are available for immediate use: you don’t need to enable these in the transaction template to be able to access them via SDK. (However, those `Other`, `Other1`, `Other2` fields and their values are viewable and printable in QuickBooks only if the transaction template has these enabled!) `Note`: you cannot use `DataExtDef` to define `Other`, `Other1`, `Other2` for the transaction. There is no need to in any case. Those are automatically available. Notice that the `Other`, `Other1`, and `Other2` names are the real SDK names for those custom fields: that is, their `DataExtName` value will always be `Other`, `Other1`, or `Other2`. Even if the user has re-labelled those custom fields to something else, such as “Barracks Number”, or “`Max` Headroom”, or even “Pleni Potentiary”. This re-labelling has no effect on the SDK. You’ll always write to them or modify them as `Other`, `Other1`, or `Other2`. */
  Other?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** One line of the sales receipt. Compare with `SalesReceiptLineGroup`, which represents a previously defined group of lines in the sales receipt. */
  SalesReceiptLineRet?: SalesReceiptLineRet;
  /** Represents a previously defined group of lines in the sales receipt. Compare with `SalesReceiptLine`, which represents just one line in the sales receipt. */
  SalesReceiptLineGroupRet?: SalesReceiptLineGroupRet;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface SalesRepAdd {
  /** The initials of a sales representative’s name. */
  Initial: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Refers to the sales representative’s full information on the Employee, Vendor, or `OtherName` list. In a request, if a `SalesRepEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Notice that you cannot supply a customer name here. */
  SalesRepEntityRef: SalesRepEntityRef;
}

export interface SalesRepAddRq {
  SalesRepAdd: SalesRepAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesRepAddRs {
  SalesRepRet?: SalesRepRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesRepEntityRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface SalesRepMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The initials of a sales representative’s name. */
  Initial?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Refers to the sales representative’s full information on the Employee, Vendor, or `OtherName` list. In a request, if a `SalesRepEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Notice that you cannot supply a customer name here. */
  SalesRepEntityRef?: SalesRepEntityRef;
}

export interface SalesRepModRq {
  SalesRepMod: SalesRepMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesRepModRs {
  SalesRepRet?: SalesRepRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesRepQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesRepQueryRs {
  SalesRepRet: SalesRepRet[];
}

export interface SalesRepRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface SalesRepRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The initials of a sales representative’s name. */
  Initial: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Refers to the sales representative’s full information on the Employee, Vendor, or `OtherName` list. In a request, if a `SalesRepEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Notice that you cannot supply a customer name here. */
  SalesRepEntityRef: SalesRepEntityRef;
}

export interface SalesTaxCodeAdd {
  /** Short name that will appear on sales forms to identify the tax status of an item. The `Desc` element gives a longer explanation of `Name`. `Name` must be unique, and it is not case-sensitive. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Indicates whether this sales-tax code is tracking taxable sales. For any particular sales-tax code, `IsTaxable` cannot be modified once the sales-tax code has been used in a transaction. If the “Do You Charge Sales Tax?” preference is set to Yes within QuickBooks, the default value of `IsTaxable` is true. If the “Do You Charge Sales Tax?” preference is set to No, the default value of `IsTaxable` is false. */
  IsTaxable: boolean;
  /** Desc gives a longer explanation of `Name`. */
  Desc?: string;
  /** For future use with international versions of QuickBooks. */
  ItemPurchaseTaxRef?: ItemPurchaseTaxRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
}

export interface SalesTaxCodeAddRq {
  SalesTaxCodeAdd: SalesTaxCodeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesTaxCodeAddRs {
  SalesTaxCodeRet?: SalesTaxCodeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesTaxCodeMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** Short name that will appear on sales forms to identify the tax status of an item. The `Desc` element gives a longer explanation of `Name`. `Name` must be unique, and it is not case-sensitive. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Indicates whether this sales-tax code is tracking taxable sales. For any particular sales-tax code, `IsTaxable` cannot be modified once the sales-tax code has been used in a transaction. If the “Do You Charge Sales Tax?” preference is set to Yes within QuickBooks, the default value of `IsTaxable` is true. If the “Do You Charge Sales Tax?” preference is set to No, the default value of `IsTaxable` is false. */
  IsTaxable?: boolean;
  /** Desc gives a longer explanation of `Name`. */
  Desc?: string;
  /** For future use with international versions of QuickBooks. */
  ItemPurchaseTaxRef?: ItemPurchaseTaxRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
}

export interface SalesTaxCodeModRq {
  SalesTaxCodeMod: SalesTaxCodeMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesTaxCodeModRs {
  SalesTaxCodeRet?: SalesTaxCodeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesTaxCodeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesTaxCodeQueryRs {
  SalesTaxCodeRet: SalesTaxCodeRet[];
}

export interface SalesTaxCodeRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface SalesTaxCodeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** Short name that will appear on sales forms to identify the tax status of an item. The `Desc` element gives a longer explanation of `Name`. `Name` must be unique, and it is not case-sensitive. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Indicates whether this sales-tax code is tracking taxable sales. For any particular sales-tax code, `IsTaxable` cannot be modified once the sales-tax code has been used in a transaction. If the “Do You Charge Sales Tax?” preference is set to Yes within QuickBooks, the default value of `IsTaxable` is true. If the “Do You Charge Sales Tax?” preference is set to No, the default value of `IsTaxable` is false. */
  IsTaxable: boolean;
  /** Desc gives a longer explanation of `Name`. */
  Desc?: string;
  /** For future use with international versions of QuickBooks. */
  ItemPurchaseTaxRef?: ItemPurchaseTaxRef;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Taxes can be reflected in transaction line items The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward. When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate. One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax. If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
}

/** @default: Canada */
export type SalesTaxCountry = "Australia" | "Canada" | "UK" | "US";

export interface SalesTaxPaymentCheckAdd {
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written.

  In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef: PayeeEntityRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** Refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. If a `BankAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  BankAccountRef: BankAccountRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once.

  Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `ISalesTaxPaymentCheckLineRet` objects, each representing one line in the sales-tax payment check. */
  SalesTaxPaymentCheckLineAdd:
    | SalesTaxPaymentCheckLineAdd
    | SalesTaxPaymentCheckLineAdd[];
}

export interface SalesTaxPaymentCheckAddRq {
  SalesTaxPaymentCheckAdd: SalesTaxPaymentCheckAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesTaxPaymentCheckAddRs {
  SalesTaxPaymentCheckRet?: SalesTaxPaymentCheckRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesTaxPaymentCheckLineAdd {
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward.

  When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate.

  One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** A monetary amount. */
  Amount: string;
}

export interface SalesTaxPaymentCheckLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.)

  If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** A sales-tax item is used to calculate a single sales tax that is collected at a specified rate and paid to a single agency. (Compare with the `ItemSalesTaxGroupAdd` message.) An `ItemSalesTaxRef` aggregate refers to an item on this list. In a request, if an `ItemSalesTaxRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  Taxes can be reflected in transaction line items

  The following information refers to invoices specifically, but it also applies to sales receipts. Generally its best to assign a tax item or tax group item to an invoice and allow QuickBooks to apply the same tax to all taxable items on the invoice. However in some situations multiple tax combinations are required, so this method doesn’t work. In this case one must use techniques to apply the taxes in the invoice itself as line items. Using lines to apply taxes isn’t always straight forward.

  When applying taxes as line items, only single tax items can be used, tax groups can only be used for the entire invoice. If you have multiple taxes which apply to all taxable items, and one or more other taxes that only apply to some of the items on an invoice its better to use a tax group which applies to the entire invoice for the taxes which applies to all taxable items and then apply the other taxes in the invoice itself. One applies a tax or tax group to an entire invoice by using the `ItemSalesTaxRef` aggregate.

  One can use subtotals to apply a single tax line to multiple items in an invoice, but the tax is only applied automatically for the first tax line after the subtotal line. Any other tax lines which need to be applied to the subtotal line must supply their own amount. If you don’t supply an amount the amount comes out as zero and the tax line is useless. When one does supply an amount, the amount of tax on the subtotal also shows up in the rate column for that tax line. There isn’t any way for the rate to show up as anything other than the amount of the tax.

  If you have a complicated tax situation where no single tax applies to all taxable items on the invoice, you must choose a zero percent tax to apply for the entire invoice. It is recommended to name such a tax item “Tax Calculated On Invoice” so that it’s clear that the tax is not being applied by QuickBooks on the entire invoice. */
  ItemSalesTaxRef?: ItemSalesTaxRef;
  /** A monetary amount. */
  Amount?: string;
}

export interface SalesTaxPaymentCheckMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. If a `BankAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  BankAccountRef?: BankAccountRef;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once. Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
}

export interface SalesTaxPaymentCheckModRq {
  SalesTaxPaymentCheckMod: SalesTaxPaymentCheckMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface SalesTaxPaymentCheckModRs {
  SalesTaxPaymentCheckRet?: SalesTaxPaymentCheckRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface SalesTaxPaymentCheckQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to the item name or ID. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. */
  ItemFilter?: ItemFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface SalesTaxPaymentCheckQueryRs {
  SalesTaxPaymentCheckRet: SalesTaxPaymentCheckRet[];
}

export interface SalesTaxPaymentCheckRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** Refers to a payee who is a customer, vendor, employee, or person on the “other names” list. In a request, if a `PayeeEntityRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored.

  In a Check message, `PayeeEntityRef` refers to the person or company to whom the check is written.

  In `CreditCardCharge` and `CreditCardCredit` messages, `PayeeEntityRef` refers to the vendor or company from whom merchandise was purchased. (`PayeeEntityRef` corresponds to the choice in the Purchased From list in QuickBooks.) */
  PayeeEntityRef?: PayeeEntityRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** Refers to the account from which the funds are being drawn for this check, for example, Checking or Savings. If a `BankAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  BankAccountRef: BankAccountRef;
  /** A monetary amount. */
  Amount: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Additional information. */
  Memo?: string;
  /** If an address request fails, some combination of address fields might be too long. In a Check, `BillPaymentCheck`, or `SalesTaxPaymentCheck` message, `Address` is the address that will print on the check. */
  Address?: Address;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  AddressBlock?: AddressBlock;
  /** If `IsToBePrinted` is set to true, this transaction is on a list of forms to be printed later. The user can then choose to print all these forms at once.

  Notice that setting this field to true does not actually perform the printing. Only the QuickBooks user can do that from within QuickBooks. This cannot be done from the SDK. Setting this field to false does not prevent the QuickBooks user from printing the transaction later. It simply results in the transaction NOT being placed in the list of transactions to be printed. */
  IsToBePrinted?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `ISalesTaxPaymentCheckLineRet` objects, each representing one line in the sales-tax payment check. */
  SalesTaxPaymentCheckLineRet?:
    | SalesTaxPaymentCheckLineRet
    | SalesTaxPaymentCheckLineRet[];
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface SalesTaxReturnLineRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface SalesTaxReturnRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface SecondaryContact {
  /** The name of the contact. */
  ContactName: string;
  /** The value of the contact field. */
  ContactValue: string;
  /** Relationship of emergency contact information to the employee. */
  Relation?: Relation;
}

export type SerialNumberAddedOrRemoved = "Added" | "Removed";

export interface SerialNumberAdjustment {
  /** Serial number that will be added to inventory. */
  AddSerialNumber?: string;
  /** Serial number that will be removed from inventory. */
  RemoveSerialNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber?: string;
  /** Location within the Inventory Site. */
  InventorySiteLocationRef?: InventorySiteLocationRef;
}

export interface Service {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** Indicates the provider of the subscribed service, for example, Intuit. */
  Domain: string;
  /** The status of the Intuit services that the company is or has been subscribed to, for example, Intuit Payroll, QBMS. */
  ServiceStatus: ServiceStatus;
}

export type ServiceStatus =
  | "Active"
  | "Expired"
  | "Never"
  | "Pending"
  | "Suspended"
  | "Terminated"
  | "Trial";

export interface SetCredit {
  /** The ID of the credit memo that you are applying to this invoice or bill. */
  CreditTxnID: string;
  /** Amount of a credit that is applied to a customer’s invoice, or amount of a payment that is applied to a particular bill or vendor credit. */
  AppliedAmount: string;
  /** Option to override credit. */
  Override?: boolean;
}

export interface ShipAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface ShipAddressBlock {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface ShipMethodRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ShipToAddress {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
  /** Flag that address is the default ship to address. */
  DefaultShipTo?: boolean;
}

export interface ShipToEntityRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface SickHours {
  /** The total number of hours currently available for the employee to use. If this value is empty, it will default to 0. */
  HoursAvailable?: string;
  /** Indicates how an employee accrues time off. If you include a blank `AccrualPeriod` element in an `EmployeeMod` message, you’ll receive an error. The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  AccrualPeriod?: AccrualPeriod;
  /** The number of hours that the employee will accrue per accrual period. The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  HoursAccrued?: string;
  /** The maximum number of hours that the employee can accrue. (QuickBooks itself does not enforce this limit, however. `HoursAvailable` can be greater than `MaximumHours`.) The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  MaximumHours?: string;
  /** Indicates whether or not the hours accrued resets to zero at the beginning of the new year. If you include a blank `IsResettingHoursEachNewYear` element in an `EmployeeMod` message, you’ll receive an error. */
  IsResettingHoursEachNewYear?: boolean;
  /** When used in the `SickHours` or `VacationHours` aggregates, refers to the number of sick leave or vacation hours used in the current year. */
  HoursUsed?: string;
  /** When used in the `SickHours` or `VacationHours` aggregates, refers to the date on which sick leave or vacation hours in the current year began to accrue. */
  AccrualStartDate?: string;
}

export interface SiteAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
}

export interface SiteAddressBlock {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface SiteFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
}

export type SOChannel = "Blank" | "Ecommerce";

export type SpecialAccountType =
  | "AccountsPayable"
  | "AccountsReceivable"
  | "CondenseItemAdjustmentExpenses"
  | "CostOfGoodsSold"
  | "DirectDepositLiabilities"
  | "Estimates"
  | "ExchangeGainLoss"
  | "InventoryAssets"
  | "ItemReceiptAccount"
  | "OpeningBalanceEquity"
  | "PayrollExpenses"
  | "PayrollLiabilities"
  | "PettyCash"
  | "PurchaseOrders"
  | "ReconciliationDifferences"
  | "RetainedEarnings"
  | "SalesOrders"
  | "SalesTaxPayable"
  | "UncategorizedExpenses"
  | "UncategorizedIncome"
  | "UndepositedFunds";

export type SpecialItemType =
  | "FinanceCharge"
  | "ReimbursableExpenseGroup"
  | "ReimbursableExpenseSubtotal";

export interface StandardTermsAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The number of days until payment is due. */
  StdDueDays?: number;
  /** If payment is received within `StdDiscountDays` number of days, then `DiscountPct` will apply to the payment. */
  StdDiscountDays?: number;
  /** If payment is received within `StdDiscountDays` number of days, then this discount will apply to the payment. `DiscountPct` must be between 0 and 100. */
  DiscountPct?: string;
}

export interface StandardTermsAddRq {
  StandardTermsAdd: StandardTermsAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface StandardTermsAddRs {
  StandardTermsRet?: StandardTermsRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface StandardTermsQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface StandardTermsQueryRs {
  StandardTermsRet: StandardTermsRet[];
}

export interface StandardTermsRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** The number of days until payment is due. */
  StdDueDays?: number;
  /** If payment is received within `StdDiscountDays` number of days, then `DiscountPct` will apply to the payment. */
  StdDiscountDays?: number;
  /** If payment is received within `StdDiscountDays` number of days, then this discount will apply to the payment. `DiscountPct` must be between 0 and 100. */
  DiscountPct?: string;
}

/** @default: Hot */
export type Status = "Cold" | "Hot" | "Warm";

export interface SubscribedServices {
  /** The list of the Intuit services that the company is or has been subscribed to, for example, Intuit Payroll, QBMS. */
  Service?: Service | Service[];
}

export interface SubtotalRow {
  /** `RowData` describes one row in the report. */
  RowData?: RowData;
  /** A list of `IColData` objects, each of which describes the data in one cell of the report. */
  ColData?: ColData | ColData[];
}

export type SummarizeBudgetColumnsBy = "Class" | "Customer" | "Date";

export type SummarizeBudgetRowsBy = "Account" | "Class" | "Customer";

export type SummarizeColumnsBy =
  | "Account"
  | "BalanceSheet"
  | "Class"
  | "Customer"
  | "CustomerType"
  | "Day"
  | "Employee"
  | "FourWeek"
  | "HalfMonth"
  | "IncomeStatement"
  | "ItemDetail"
  | "ItemType"
  | "Month"
  | "Payee"
  | "PaymentMethod"
  | "PayrollItemDetail"
  | "PayrollYtdDetail"
  | "Quarter"
  | "SalesRep"
  | "SalesTaxCode"
  | "ShipMethod"
  | "Terms"
  | "TotalOnly"
  | "TwoWeek"
  | "Vendor"
  | "VendorType"
  | "Week"
  | "Year";

export type SummarizeRowsBy =
  | "Account"
  | "BalanceSheet"
  | "Class"
  | "Customer"
  | "CustomerType"
  | "Day"
  | "Employee"
  | "FourWeek"
  | "HalfMonth"
  | "IncomeStatement"
  | "ItemDetail"
  | "ItemType"
  | "Month"
  | "Payee"
  | "PaymentMethod"
  | "PayrollItemDetail"
  | "PayrollYtdDetail"
  | "Quarter"
  | "SalesRep"
  | "SalesTaxCode"
  | "ShipMethod"
  | "TaxLine"
  | "Terms"
  | "TotalOnly"
  | "TwoWeek"
  | "Vendor"
  | "VendorType"
  | "Week"
  | "Year";

export interface SupervisorRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type TaxForm =
  | "Form990"
  | "Form990PF"
  | "Form990T"
  | "Form1040"
  | "Form1065"
  | "Form1120"
  | "Form1120S"
  | "OtherOrNone";

export interface TaxLineInfoRet {
  /** An internal representation of the tax line associated with this account. */
  TaxLineID: number;
  /** The name of the tax line associated with this account, as it appears on the tax form. */
  TaxLineName?: string;
}

export interface TaxOnPurchasesAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TaxOnSalesAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TaxVendorRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TemplateRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TermsRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TextRow {
  /** The row number. Rows are numbered from top to bottom, starting with 1. */
  RowNumber: number;
  /** The data in this cell of the report. */
  Value: string;
}

/** @default: Comma */
export type ThousandSeparator = "Apostrophe" | "Comma" | "Period" | "Space";

/** @default: XX_XXX_XXX */
export type ThousandSeparatorGrouping = "X_XX_XX_XXX" | "XX_XXX_XXX";

export interface TimeReportQueryRq {
  /** Allows you to report on time that has been recorded in a particular category. */
  TimeReportType: TimeReportType;
  /** Set `DisplayReport` to true to display this report within the QuickBooks UI. (Default is false.) If you want the request to display the report without returning any data to your application, set the `responseData` attribute to `includeNone`. */
  DisplayReport?: boolean;
  /** If you omit both `ToReportDate` and `FromReportDate`, the report will cover the current fiscal year to date. */
  ReportPeriod?: ReportPeriod;
  /** The time period covered by this report. */
  ReportDateMacro?: ReportDateMacro;
  /** Allows you to query for a specified name type (customer, employee, vendor, or other) or query for specific list elements. */
  ReportEntityFilter?: ReportEntityFilter;
  /** Allows you to query for a specified item type (for example, discount, inventory, or non-inventory) or query for specific list elements. */
  ReportItemFilter?: ReportItemFilter;
  /** Allows you to query for a specified class. Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. */
  ReportClassFilter?: ReportClassFilter;
  /** `SummarizeColumnsBy` determines which data the report calculates and how the columns will be labeled across the top of the report. For example, if you set the value to `scbTwoWeek`, the report’s column labels might be “Feb 10-23, 02,” “Feb 24-Mar9, 02,” and so on. */
  SummarizeColumnsBy?: SummarizeColumnsBy;
  /** A list of enum values showing which columns you want the report to return. (The report won’t return columns other than the ones you specify here.) */
  IncludeColumn?: IncludeColumn | IncludeColumn[];
  /** The default value is false, which means that the report will not include any subcolumn information. To include all available types of subcolumns for this report, set `IncludeSubcolumns` to true. The SDK will not return subcolumn information for data that can be easily computed. (For example, the SDK does not return the “percent of row” column.) */
  IncludeSubcolumns?: boolean;
  /** Specifies the type of year that will be used for this report. */
  ReportCalendar?: ReportCalendar;
  /** Specifies whether you want the report to include only rows with active information, only rows with nonzero values, or all rows regardless of their content or active status. */
  ReturnRows?: ReturnRows;
  /** Specifies whether you want the report to include only columns with active information, only columns with nonzero values, or all columns regardless of their content or active status. */
  ReturnColumns?: ReturnColumns;
}

export interface TimeReportQueryRs {
  ReportRet: ReportRet[];
}

export type TimeReportType =
  | "TimeByItem"
  | "TimeByJobDetail"
  | "TimeByJobSummary"
  | "TimeByName";

export interface TimeTrackingAdd {
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef: EntityRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** A service item refers to services that a business charges for or purchases. Examples include specialized labor, consulting hours, and professional fees. An `ItemServiceRef` aggregate refers to an item on the `ItemService` list. In a request, if an `ItemServiceRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `TimeTracking` message, `ItemServiceRef` refers to the type of work. If no `CustomerRef` is specified, then `ItemServiceRef` is not needed. If `IsBillable` is set to true, then `TimeTrackingAdd` must include both `ItemServiceRef` and `CustomerRef`. */
  ItemServiceRef?: ItemServiceRef;
  /** Time spent doing the work. In a `TimeTrackAdd` request, notice that although you can specify seconds, seconds are not returned in the response because the UI does not use seconds. */
  Duration: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each payroll wage item describes and names a payment scheme, for example, Regular Pay or Overtime Pay. A `PayrollItemWageRef` aggregate refers to one of these wage items. In a request, if a `PayrollItemWageRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Within QuickBooks, a timesheet can specify a payroll wage item only if the following criteria are met: The name on the timesheet (which corresponds to the `EntityRef` in the `TimeTracking` object) is on the QuickBooks Employee list, and The “Use time data to create paychecks” preference is turned on in the QuickBooks Payroll Info window that provides detailed employee information employee. */
  PayrollItemWageRef?: PayrollItemWageRef;
  /** Additional information. */
  Notes?: string;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** NOT USABLE IN QBXML SPEC 6.0 AND LATER!! Use `BillableStatus` instead. If `IsBillable` is true, the tracked time is billable, and you must specify `CustomerRef` and `ItemServiceRef` so that an invoice can be created. If no invoice will be created, set `IsBillable` to false. (`IsBillable` is true by default.) */
  IsBillable?: boolean;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
}

export interface TimeTrackingAddRq {
  TimeTrackingAdd: TimeTrackingAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TimeTrackingAddRs {
  TimeTrackingRet?: TimeTrackingRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface TimeTrackingEntityFilter {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
}

export interface TimeTrackingMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef: EntityRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** A service item refers to services that a business charges for or purchases. Examples include specialized labor, consulting hours, and professional fees. An `ItemServiceRef` aggregate refers to an item on the `ItemService` list. In a request, if an `ItemServiceRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `TimeTracking` message, `ItemServiceRef` refers to the type of work. If no `CustomerRef` is specified, then `ItemServiceRef` is not needed. If `IsBillable` is set to true, then `TimeTrackingAdd` must include both `ItemServiceRef` and `CustomerRef`. */
  ItemServiceRef?: ItemServiceRef;
  /** Time spent doing the work. In a `TimeTrackAdd` request, notice that although you can specify seconds, seconds are not returned in the response because the UI does not use seconds. */
  Duration: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each payroll wage item describes and names a payment scheme, for example, Regular Pay or Overtime Pay. A `PayrollItemWageRef` aggregate refers to one of these wage items. In a request, if a `PayrollItemWageRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Within QuickBooks, a timesheet can specify a payroll wage item only if the following criteria are met: The name on the timesheet (which corresponds to the `EntityRef` in the `TimeTracking` object) is on the QuickBooks Employee list, and The “Use time data to create paychecks” preference is turned on in the QuickBooks Payroll Info window that provides detailed employee information employee. */
  PayrollItemWageRef?: PayrollItemWageRef;
  /** Additional information. */
  Notes?: string;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
}

export interface TimeTrackingModRq {
  TimeTrackingMod: TimeTrackingMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TimeTrackingModRs {
  TimeTrackingRet?: TimeTrackingRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface TimeTrackingQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** Allows you to query for one or more names on the QuickBooks Vendor list, Employee list, or `Other` Names list. */
  TimeTrackingEntityFilter?: TimeTrackingEntityFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TimeTrackingQueryRs {
  TimeTrackingRet: TimeTrackingRet[];
}

export interface TimeTrackingRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** A QuickBooks “entity” is a customer, vendor, employee, or person on the QuickBooks “other names” list. Special cases to note: In a `BillToPayQuery` message, `EntityRef` refers to the vendor name.In `JournalCreditLine` and `JournalDebitLine` messages for A/R accounts, `EntityRef` must refer to a customer, or else the transaction will not be recorded. For A/P accounts the `EntityRef` must refer to a vendor, or else the transaction will not be recorded.In a `TimeTracking` message, `EntityRef` cannot refer to a customer, only to an employee, vendor, or person on the “other names” list whose time is being tracked. */
  EntityRef: EntityRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** A service item refers to services that a business charges for or purchases. Examples include specialized labor, consulting hours, and professional fees. An `ItemServiceRef` aggregate refers to an item on the `ItemService` list. In a request, if an `ItemServiceRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a `TimeTracking` message, `ItemServiceRef` refers to the type of work. If no `CustomerRef` is specified, then `ItemServiceRef` is not needed. If `IsBillable` is set to true, then `TimeTrackingAdd` must include both `ItemServiceRef` and `CustomerRef`. */
  ItemServiceRef?: ItemServiceRef;
  /** Time spent doing the work. In a `TimeTrackAdd` request, notice that although you can specify seconds, seconds are not returned in the response because the UI does not use seconds. */
  Duration: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Each payroll wage item describes and names a payment scheme, for example, Regular Pay or Overtime Pay. A `PayrollItemWageRef` aggregate refers to one of these wage items. In a request, if a `PayrollItemWageRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Within QuickBooks, a timesheet can specify a payroll wage item only if the following criteria are met: The name on the timesheet (which corresponds to the `EntityRef` in the `TimeTracking` object) is on the QuickBooks Employee list, and The “Use time data to create paychecks” preference is turned on in the QuickBooks Payroll Info window that provides detailed employee information employee. */
  PayrollItemWageRef?: PayrollItemWageRef;
  /** Additional information. */
  Notes?: string;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** NOT USABLE IN QBXML SPEC 6.0 AND LATER!! Use `BillableStatus` instead. If `IsBillable` is true, the tracked time is billable, and you must specify `CustomerRef` and `ItemServiceRef` so that an invoice can be created. If no invoice will be created, set `IsBillable` to false. (`IsBillable` is true by default.) */
  IsBillable?: boolean;
  /** If `IsBilled` is true, the tracked time has already been billed. */
  IsBilled?: boolean;
}

export interface ToInventorySiteLocationRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface ToInventorySiteRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TotalBalanceFilter {
  /** Indicates whether to filter for amounts that are less than, equal to or less than, exactly equal to, greater than, or equal to or greater than the given `Amount`. */
  Operator: Operator;
  /** The monetary amount to which `Operator` refers. */
  Amount: string;
}

export interface TotalRow {
  /** `RowData` describes one row in the report. */
  RowData?: RowData;
  /** A list of `IColData` objects, each of which describes the data in one cell of the report. */
  ColData?: ColData | ColData[];
}

/** @default: CardNotPresent */
export type TransactionMode = "CardNotPresent" | "CardPresent";

export interface TransferAdd {
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Account that money will be transferred from. */
  TransferFromAccountRef?: TransferFromAccountRef;
  /** Account that money will be transferred to. */
  TransferToAccountRef?: TransferToAccountRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information. */
  Memo?: string;
}

export interface TransferAddRq {
  TransferAdd: TransferAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TransferAddRs {
  TransferRet?: TransferRet;
}

export interface TransferFromAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TransferInventoryAdd {
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Inventory site that transfer will be taken from. */
  FromInventorySiteRef: FromInventorySiteRef;
  /** Inventory site that transfer will be sent to. */
  ToInventorySiteRef: ToInventorySiteRef;
  /** Additional information. */
  Memo?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** List of lines for inventory transfers. */
  TransferInventoryLineAdd?:
    | TransferInventoryLineAdd
    | TransferInventoryLineAdd[];
}

export interface TransferInventoryAddRq {
  TransferInventoryAdd: TransferInventoryAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TransferInventoryAddRs {
  TransferInventoryRet?: TransferInventoryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface TransferInventoryLineAdd {
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Location within the inventory site that transfer will be taken from. */
  FromInventorySiteLocationRef?: FromInventorySiteLocationRef;
  /** Location within the inventory site that transfer will be sent to. */
  ToInventorySiteLocationRef?: ToInventorySiteLocationRef;
  /** Quantity of items transferred. */
  QuantityToTransfer?: number;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
}

export interface TransferInventoryLineMod {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Location within the inventory site that transfer will be taken from. */
  FromInventorySiteLocationRef?: FromInventorySiteLocationRef;
  /** Location within the inventory site that transfer will be sent to. */
  ToInventorySiteLocationRef?: ToInventorySiteLocationRef;
  /** Quantity of items transferred. */
  QuantityToTransfer?: number;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
}

export interface TransferInventoryLineRet {
  /** Identification number of the transaction line. (`TxnLineID` is supported as of v2.0 of the SDK. With qbXML v1.0 and v1.1, `TxnLineID` is always returned as zero.) If you need to add a new transaction line in a transaction Mod request, you can do so by setting the `TxnLineID` to -1. */
  TxnLineID: string;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Location within the inventory site that transfer will be taken from. */
  FromInventorySiteLocationRef?: FromInventorySiteLocationRef;
  /** Location within the inventory site that transfer will be sent to. */
  ToInventorySiteLocationRef?: ToInventorySiteLocationRef;
  /** Quantity of items transferred. */
  QuantityTransferred?: number;
  /** The serial number of the asset. */
  SerialNumber?: string;
  /** The lot number of the asset. */
  LotNumber?: string;
  /** The expiration date of the inventory serial/lot number. Expiration `Date` is supported from QB Desktop 2023 version 3 (USA & Canada) and SDK 16.0. */
  ExpirationDateForSerialLotNumber: string;
}

export interface TransferInventoryMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Inventory site that transfer will be taken from. */
  FromInventorySiteRef?: FromInventorySiteRef;
  /** Inventory site that transfer will be sent to. */
  ToInventorySiteRef?: ToInventorySiteRef;
  /** Additional information. */
  Memo?: string;
  /** List of lines for inventory transfers. */
  TransferInventoryLineMod?:
    | TransferInventoryLineMod
    | TransferInventoryLineMod[];
}

export interface TransferInventoryModRq {
  TransferInventoryMod: TransferInventoryMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TransferInventoryModRs {
  TransferInventoryRet?: TransferInventoryRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface TransferInventoryQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Allows you to report on Sites. */
  SiteFilter?: SiteFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TransferInventoryQueryRs {
  TransferInventoryRet: TransferInventoryRet[];
}

export interface TransferInventoryRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Inventory site that transfer will be taken from. */
  FromInventorySiteRef?: FromInventorySiteRef;
  /** Inventory site that transfer will be sent to. */
  ToInventorySiteRef?: ToInventorySiteRef;
  /** Additional information. */
  Memo?: string;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** List of lines for inventory transfers. */
  TransferInventoryLineRet?:
    | TransferInventoryLineRet
    | TransferInventoryLineRet[];
}

export interface TransferMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Account that money will be transferred from. */
  TransferFromAccountRef?: TransferFromAccountRef;
  /** Account that money will be transferred to. */
  TransferToAccountRef?: TransferToAccountRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information. */
  Memo?: string;
}

export interface TransferModRq {
  TransferMod: TransferMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TransferModRs {
  TransferRet?: TransferRet;
}

export interface TransferQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface TransferQueryRs {
  TransferRet: TransferRet[];
}

export interface TransferRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** Account that money will be transferred from. */
  TransferFromAccountRef?: TransferFromAccountRef;
  /** Balance for the from account. */
  FromAccountBalance?: string;
  /** Account that money will be transferred to. */
  TransferToAccountRef?: TransferToAccountRef;
  /** Balance for the to account. */
  ToAccountBalance?: string;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** A monetary amount. */
  Amount?: string;
  /** Additional information. */
  Memo?: string;
}

export interface TransferToAccountRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface TxnDateRangeFilter {
  /** Selects transactions created on or after this date. Both `FromTxnDate` and `ToTxnDate` must be between 01/01/1901 and 12/31/9999.

  If you omit `FromTxnDate`, it will be set to 1970-01-01 (1969-12-31 PST). */
  FromTxnDate?: string;
  /** Selects transactions created on or before this date. Both `ToTxnDate` and `FromTxnDate` must be between 01/01/1901 and 12/31/9999. If you omit `ToTxnDate`, it will be set to 2038-01-19 (2038-01-18 PST). */
  ToTxnDate?: string;
  /** Refers to the transaction date, not the last modification date. Do not include `DateMacro` if either `FromModifedDate` or `ToModifiedDate` are specified. If a query does not specify `DateMacro`, `FromModifedDate`, or `ToModifiedDate`, it includes all dates.

  `DateMacro` values, in alphabetical order, that are new with QBFC3:

  `dmAll`, `dmdmLastCalendarQuarter`, `dmdmLastCalendarQuarterToDate`, `dmdmLastCalendarYear`, `dmdmLastCalendarYearToDate`, `dmLastFiscalQuarterToDate`, `dmLastFiscalYearToDate`, `dmLastMonthToDate`, `dmLastWeekToDate`, `dmNextCalendarQuarter`, `dmNextCalendarYear`, `dmNextFiscalQuarter`, `dmNextFiscalYear`, `dmNextFourWeeks`, `dmNextMonth`, `dmNextWeek`, `dmThisCalendarQuarter`, `dmThisCalendarQuarterToDate`, `dmThisCalendarYear`, dm `ThisCalendarYearToDate`, `dmThisFiscalQuarter`, `dmThisFiscalYear`, `dmThisMonth`, `dmThisWeek`, `dmThisWeekToDate`, `dmToday`, `dmYesterday`

  The list given when you click `IQBENDateMacroType` shows the complete list of valid version 3.0 values. */
  DateMacro?: DateMacro;
}

export type TxnType =
  | "ARRefundCreditCard"
  | "Bill"
  | "BillPaymentCheck"
  | "BillPaymentCreditCard"
  | "BuildAssembly"
  | "Charge"
  | "Check"
  | "CreditCardCharge"
  | "CreditCardCredit"
  | "CreditMemo"
  | "Deposit"
  | "Estimate"
  | "InventoryAdjustment"
  | "Invoice"
  | "ItemReceipt"
  | "JournalEntry"
  | "LiabilityAdjustment"
  | "Paycheck"
  | "PayrollLiabilityCheck"
  | "PurchaseOrder"
  | "ReceivePayment"
  | "SalesOrder"
  | "SalesReceipt"
  | "SalesTaxPaymentCheck"
  | "Transfer"
  | "VendorCredit"
  | "YTDAdjustment";

export type TxnTypeFilter =
  | "All"
  | "ARRefundCreditCard"
  | "Bill"
  | "BillPaymentCheck"
  | "BillPaymentCreditCard"
  | "BuildAssembly"
  | "Charge"
  | "Check"
  | "CreditCardCharge"
  | "CreditCardCredit"
  | "CreditMemo"
  | "Deposit"
  | "Estimate"
  | "InventoryAdjustment"
  | "Invoice"
  | "ItemReceipt"
  | "JournalEntry"
  | "LiabilityAdjustment"
  | "Paycheck"
  | "PayrollLiabilityCheck"
  | "PurchaseOrder"
  | "ReceivePayment"
  | "SalesOrder"
  | "SalesReceipt"
  | "SalesTaxPaymentCheck"
  | "Transfer"
  | "VendorCredit"
  | "YTDAdjustment";

export interface UnitOfMeasureSetRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export type USCitizen = "No" | "Yes";

export type UseTimeDataToCreatePaychecks =
  | "DoNotUseTimeData"
  | "NotSet"
  | "UseTimeData";

export type USVeteran = "No" | "Yes";

export interface VacationHours {
  /** The total number of hours currently available for the employee to use. If this value is empty, it will default to 0. */
  HoursAvailable?: string;
  /** Indicates how an employee accrues time off. If you include a blank `AccrualPeriod` element in an `EmployeeMod` message, you’ll receive an error. The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  AccrualPeriod?: AccrualPeriod;
  /** The number of hours that the employee will accrue per accrual period. The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  HoursAccrued?: string;
  /** The maximum number of hours that the employee can accrue. (QuickBooks itself does not enforce this limit, however. `HoursAvailable` can be greater than `MaximumHours`.) The default value is whatever the QuickBooks user has set in the QuickBooks Employee Preferences. */
  MaximumHours?: string;
  /** Indicates whether or not the hours accrued resets to zero at the beginning of the new year. If you include a blank `IsResettingHoursEachNewYear` element in an `EmployeeMod` message, you’ll receive an error. */
  IsResettingHoursEachNewYear?: boolean;
  /** When used in the `SickHours` or `VacationHours` aggregates, refers to the number of sick leave or vacation hours used in the current year. */
  HoursUsed?: string;
  /** When used in the `SickHours` or `VacationHours` aggregates, refers to the date on which sick leave or vacation hours in the current year began to accrue. */
  AccrualStartDate?: string;
}

export interface ValueAdjustment {
  /** The new quantity for this inventory item. */
  NewQuantity?: number;
  /** Either a positive or negative number that shows the change in quantity for this inventory item. */
  QuantityDifference?: number;
  /** The new total value of these inventory items. (The new value does not have to equal `QuantityOnHand` times `PurchaseCost`.) */
  NewValue?: string;
  /** Either a positive or negative number that shows a change in the total value of the entire stock of this inventory item. */
  ValueDifference?: string;
}

export interface VehicleAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A descriptive text field. */
  Desc?: string;
}

export interface VehicleAddRq {
  VehicleAdd: VehicleAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VehicleAddRs {
  VehicleRet?: VehicleRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VehicleMileageAdd {
  /** A vehicle for use in `VehicleMileage` transactions. Each vehicle name must be unique. */
  VehicleRef: VehicleRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Date the trip began. If left blank, the current date at the time of transaction will be used. Notice that only dates are supported for vehicle mileage, so make sure you enter any datetime values with dates only, no time values. That is, 2002-02-02 will work for trip end date or start date, but 2002-02-02T12:20:20 will not work. */
  TripStartDate?: string;
  /** Date the trip ended. If left blank, the current date at the time of transaction will be used. Notice that only dates are supported for vehicle mileage, so make sure you enter any datetime values with dates only, no time values. That is, 2002-02-02 will work for trip end date or start date, but 2002-02-02T12:20:20 will not work. */
  TripEndDate?: string;
  /** Odometer reading at the start of the trip. `OdometerStart` and `OdometerEnd` must both be specified if `TotalMiles` is not specified. QuickBooks will calculate the total trip miles from these two values. If `TotalMiles` is specified, you cannot specify `OdometerStart` and `OdometerEnd`. */
  OdometerStart: number;
  /** Odometer reading at the end of the trip. `OdometerStart` and `OdometerEnd` must both be specified if `TotalMiles` is not specified. QuickBooks will calculate the total trip miles from these two values. If `TotalMiles` is specified, you cannot specify `OdometerStart` and `OdometerEnd`. */
  OdometerEnd: number;
  /** Total trip miles. If `TotalMiles` is specified, you cannot specify `OdometerStart` and `OdometerEnd`. If you use `OdometerStart` and `OdometerEnd` instead of `TotalMiles`, QuickBooks will calculate the total trip miles from these two values. */
  TotalMiles?: number;
  /** Additional information. */
  Notes?: string;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
}

export interface VehicleMileageAddRq {
  VehicleMileageAdd: VehicleMileageAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VehicleMileageAddRs {
  VehicleMileageRet?: VehicleMileageRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VehicleMileageQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VehicleMileageQueryRs {
  VehicleMileageRet: VehicleMileageRet[];
}

export interface VehicleMileageRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** A vehicle for use in `VehicleMileage` transactions. Each vehicle name must be unique. */
  VehicleRef?: VehicleRef;
  /** The customer list includes information about the QuickBooks user’s customers and the individual jobs that are being performed for them. A `CustomerRef` aggregate refers to one of the customers (or customer jobs) on the list. In a request, if a `CustomerRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. Special cases to note:In `SalesReceipt` and `ReceivePayment` requests, `CustomerRef` refers to the customer or customer job to which the payment is credited.In a `TimeTracking` request, `CustomerRef` refers to the customer or customer job to which this time could be billed. If `IsBillable` is set to true, `CustomerRef` is required in `TimeTrackingAdd`. In an `ExpenseLineAdd` request, if `AccountRef` refers to an A/P account, `CustomerRef` must refer to a vendor (not to a customer). If `AccountRef` refers to any other type of account, the `CustomerRef` must refer to a customer. */
  CustomerRef?: CustomerRef;
  /** Depending on the request containing it, `ItemRef` can refer to an item on any Item list such as `ItemDiscount`, `ItemInventory`, and so forth, or it may accept only a subset of item types. For example, here are some requests that impose limits on what items `ItemRef` can refer to. For `PurchaseOrder` and Bill requests, `ItemRef` cannot refer to discount items or sales-tax `itemsFor` `VehicleMilageAdd` requests, the `ItemRef` must refer to a service item or an other charge item.For `BillingRateAdd` requests, the `ItemRef` must refer to a service item. You can use an `ItemQuery` request to get information about all the items that are set up in the QuickBooks file. “Items” are line items used for fast entry on sales and purchase forms. They include services and goods that a business buys and sells, as well as special items that perform calculations–for example, subtotal, discount, and sales-tax items. Note: In a request, if an `ItemRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ItemRef?: ItemRef;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Date the trip began. If left blank, the current date at the time of transaction will be used. Notice that only dates are supported for vehicle mileage, so make sure you enter any datetime values with dates only, no time values. That is, 2002-02-02 will work for trip end date or start date, but 2002-02-02T12:20:20 will not work. */
  TripStartDate?: string;
  /** Date the trip ended. If left blank, the current date at the time of transaction will be used. Notice that only dates are supported for vehicle mileage, so make sure you enter any datetime values with dates only, no time values. That is, 2002-02-02 will work for trip end date or start date, but 2002-02-02T12:20:20 will not work. */
  TripEndDate?: string;
  /** Odometer reading at the start of the trip. `OdometerStart` and `OdometerEnd` must both be specified if `TotalMiles` is not specified. QuickBooks will calculate the total trip miles from these two values. If `TotalMiles` is specified, you cannot specify `OdometerStart` and `OdometerEnd`. */
  OdometerStart?: number;
  /** Odometer reading at the end of the trip. `OdometerStart` and `OdometerEnd` must both be specified if `TotalMiles` is not specified. QuickBooks will calculate the total trip miles from these two values. If `TotalMiles` is specified, you cannot specify `OdometerStart` and `OdometerEnd`. */
  OdometerEnd?: number;
  /** Total trip miles. If `TotalMiles` is specified, you cannot specify `OdometerStart` and `OdometerEnd`. If you use `OdometerStart` and `OdometerEnd` instead of `TotalMiles`, QuickBooks will calculate the total trip miles from these two values. */
  TotalMiles?: number;
  /** Additional information. */
  Notes?: string;
  /** The billing status of this item line or expense line. */
  BillableStatus?: BillableStatus;
  /** The mileage rate currently allowed by the tax authority (IRS) for vehicle expenses. */
  StandardMileageRate?: string;
  /** Amount calculated by multiplying the total trip miles in the current vehicle mileage transaction by the standard mileage rate currently in use. */
  StandardMileageTotalAmount?: string;
  /** In a billable vehicle mileage transaction, refers to the rate being used to charge mileage against a customer. The rate is specified in the service item or other charge item that is referenced in the `ItemRef` field of the `VehicleMileageAdd` request. */
  BillableRate?: string;
  /** In a billable vehicle mileage transaction, refers to the total charge that QuickBooks calculates by multiplying the trip total mileage by the rate specified in the item referenced by the `ItemRef`. */
  BillableAmount?: string;
}

export interface VehicleMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A descriptive text field. */
  Desc?: string;
}

export interface VehicleModRq {
  VehicleMod: VehicleMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VehicleModRs {
  VehicleRet?: VehicleRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VehicleQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VehicleQueryRs {
  VehicleRet: VehicleRet[];
}

export interface VehicleRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface VehicleRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A descriptive text field. */
  Desc?: string;
}

export interface VendorAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Email address that would be carbon copied or CC. */
  Cc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** A list of contact records. */
  Contacts?: Contacts | Contacts[];
  /** The vendor’s name as it will appear on checks sent to the vendor. (Corresponds in the QuickBooks user interface to the “Print on Check as” field of the Edit Vendor and New Vendor windows.) */
  NameOnCheck?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information about this vendor. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotes?: AdditionalNotes | AdditionalNotes[];
  /** Vendor types allow business owners to categorize vendors in ways that are meaningful for their businesses. For example, a vendor type might indicate which industry a vendor represents, or which part of the country a vendor is in. A `VendorTypeRef` aggregate refers to one of the types on the `VendorType` list. In a request, if a `VendorTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorTypeRef?: VendorTypeRef;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** Set and returned as a positive number that indicates a customer’s or vendor’s credit limit. If no value has been defined, there is no credit limit. */
  CreditLimit?: string;
  /** A character string that identifies a vendor. */
  VendorTaxIdent?: string;
  /** If `IsVendorEligibleFor1099` is set to true, `VendorTaxIdent` and `VendorAddress` are required in a vendor add request message. Otherwise, `VendorTaxIdent` and `VendorAddress` are optional. */
  IsVendorEligibleFor1099?: boolean;
  /** The opening balance of this vendor’s account. A positive number indicates money owed to this vendor. */
  OpenBalance?: string;
  /** The date of the opening balance for this vendor. */
  OpenBalanceDate?: string;
  /** Billing rates are used to override the service item rate in a time transaction (`TimeTrackingAdd`) based on the employee or vendor performing the work. Billing rates are assigned to an employee or a vendor to specify overrides to service items. */
  BillingRateRef?: BillingRateRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The country that sales tax is collected for. */
  SalesTaxCountry?: SalesTaxCountry;
  /** Indicates whether the entity is a sales tax agency. */
  IsSalesTaxAgency?: boolean;
  /** Sales tax return information. */
  SalesTaxReturnRef?: SalesTaxReturnRef;
  /** The tax registration number used in CA and UK. */
  TaxRegistrationNumber?: string;
  /** Vendor reporting period for CA or UK. This can be monthly or quarterly. */
  ReportingPeriod?: ReportingPeriod;
  /** This flag is used for CA or UK and whether tax is tracked on purchases. */
  IsTaxTrackedOnPurchases?: boolean;
  /** Account used for taxes on purchases in CA or UK. */
  TaxOnPurchasesAccountRef?: TaxOnPurchasesAccountRef;
  /** This flag is used for CA or UK and whether tax is tracked on sales. */
  IsTaxTrackedOnSales?: boolean;
  /** Account used for taxes on sales in CA or UK. */
  TaxOnSalesAccountRef?: TaxOnSalesAccountRef;
  /** For vendor in CA or UK, is there tax charged on top of tax. */
  IsTaxOnTax?: boolean;
  /** Expense account to prefill when you enter bills for this vendor. */
  PrefillAccountRef?: PrefillAccountRef | PrefillAccountRef[];
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface VendorAddress {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
  /** The city name in an address. */
  City?: string;
  /** The state name in an address. */
  State?: string;
  /** The postal code in an address. */
  PostalCode?: string;
  /** The country name in an address, or, in returned Host information (`HostRet` or `HostInfo`), the country for which this edition of QuickBooks was designed. (Possible values are US, CA, UK, and AU.) */
  Country?: string;
  /** In a `BillAddress` or `ShipAddress` aggregate, the `Note` field value is written at the bottom of the address in the form in which it appears, such as the invoice form. */
  Note?: string;
}

export interface VendorAddressBlock {
  /** The first line of an address. */
  Addr1?: string;
  /** The second line of an address (if a second line is needed). */
  Addr2?: string;
  /** The third line of an address (if a third line is needed). */
  Addr3?: string;
  /** The fourth line of an address (if a fourth line is needed). */
  Addr4?: string;
  /** The fifth line of an address (if a fifth line is needed). */
  Addr5?: string;
}

export interface VendorAddRq {
  VendorAdd: VendorAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VendorAddRs {
  VendorRet?: VendorRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VendorCreditAdd {
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef: VendorRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.) If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user. In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.`Note` (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Appears in the A/P register and in reports that include this credit. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`. You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineAdd?: ExpenseLineAdd | ExpenseLineAdd[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineAdd?: ItemLineAdd | ItemLineAdd[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineAdd?: ItemGroupLineAdd | ItemGroupLineAdd[];
}

export interface VendorCreditAddRq {
  VendorCreditAdd: VendorCreditAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VendorCreditAddRs {
  VendorCreditRet?: VendorCreditRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VendorCreditMod {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef?: VendorRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.)

  If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Appears in the A/P register and in reports that include this credit. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** Set `ClearExpenseLines` to true to clear all the expense lines. To modify individual lines, use `ExpenseLineMod`. */
  ClearExpenseLines?: boolean;
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineMod?: ExpenseLineMod | ExpenseLineMod[];
  /** Set `ClearItemLines` to true to clear all the item lines. To modify individual lines, use `ItemLineMod`. */
  ClearItemLines?: boolean;
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineMod?: ItemLineMod | ItemLineMod[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineMod?: ItemGroupLineMod | ItemGroupLineMod[];
}

export interface VendorCreditModRq {
  VendorCreditMod: VendorCreditMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VendorCreditModRs {
  VendorCreditRet?: VendorCreditRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VendorCreditQueryRq {
  /** One or more `TxnID` values. QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQuery` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID?: string[] | string;
  /** A list of one or more `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request, the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string[] | string;
  /** A list of one or more case sensitive `RefNumber` values. A `RefNumber` is a string of characters that refers to a transaction and that can be arbitrarily changed by the QuickBooks user. You should use this case sensitive ref number list rather than the older `RefNumber` list, because it provides much better performance in certain circumstances. The older `refNumber` list provided slow performance if the `refNumber` values contained letters, not just digits. This `RefNumberCaseSensitive` list, new in SDK 4.0, eliminates this performance hit. */
  RefNumberCaseSensitive?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Filters according to the dates when transactions were last modified. The `ModifiedDateRangeFilter` aggregate is not required to contain any elements, but if it is empty, we recommend that you leave it out altogether. Note that the time portion of the `FromModifiedDate` and `ToModifiedDate` fields was not supported in qbXML version 1.0 or 1.1. (To filter according to the dates when transactions were deleted, use a `TxnDeletedQuery` message.) */
  ModifiedDateRangeFilter?: ModifiedDateRangeFilter;
  /** Filters according to the original transaction dates. */
  TxnDateRangeFilter?: TxnDateRangeFilter;
  /** An entity refers to a person on the QuickBooks Customer list, Vendor list, Employee list, or `Other` Names list. You can use an `EntityQuery` request to get information about all the entities that are set up in the QuickBooks file. In an `ARRefundCreditCard` query, this must be a customer/customer job. */
  EntityFilter?: EntityFilter;
  /** Filters according to the account name or `ListID`. If the “Use account numbers” preference is enabled in the QuickBooks company file, you can specify an account number (instead of an account name) for `FullName` and get the account you’re looking for. But if numbers have been used as account names, confusion could arise. For example, if you queried for an account named 2050, and 2050 happened to be the account number of a totally different account, the query would not return what you asked for (the account named 2050), but instead would return the account with the account number 2050. This problem will not happen if the “Use account numbers” preference is turned off in the QuickBooks file, orthe account name exactly matches the account number. (In this case, query would return the correct account either way.) To avoid this problem: Do not name an account using a number unless the number exactly matches the account’s account number. If an account name must contain a number that does not match its own account number, have the QuickBooks user change the account’s name slightly, for example `to` 2050a. */
  AccountFilter?: AccountFilter;
  /** Filters according to `RefNumber`. */
  RefNumberFilter?: RefNumberFilter;
  /** Filters according to `RefNumber`. The filtering code will do a numerical comparison (if `FromRefNumber` and `ToRefNumber` only contain digits) or a lexicographical comparison (if either `FromRefNumber` or `ToRefNumber` contain any nondigit characters). In the first situation, if you need to query for a `RefNumber` that is larger than the maximum long integer value of 2147483647, one workaround is to specify a `FromRefNumber` that is less than or equal to 2147483647 without specifying a `ToRefNumber`. */
  RefNumberRangeFilter?: RefNumberRangeFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** This filter allows you to omit line items from a query response to get a smaller result. The default value is false, so line items are omitted by default. Set `IncludeLineItems` to true to include line items in the response if you don’t mind getting a larger result. */
  IncludeLineItems?: boolean;
  /** If you set `IncludeLinkedTxns` to true, then the returned object will include a list of all the transactions linked to the queried object. (This list is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items.) Each linked transaction will be represented by a `LinkedTxn` aggregate. If no linked transactions exist, no `LinkedTxn` aggregates will be returned. */
  IncludeLinkedTxns?: boolean;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface VendorCreditQueryRs {
  VendorCreditRet: VendorCreditRet[];
}

export interface VendorCreditRet {
  /** QuickBooks generates a unique `TxnID` for each transaction that is added to QuickBooks. A `TxnID` returned from a request can be used to refer to the transaction in subsequent requests.

  Notice that you cannot supply the `TxnID` of a `TimeTracking` transaction to `TransactionQueryRq` requests. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This behavior reflects the behavior in the QuicKBooks UI in the Find window. */
  TxnID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** An identifying number for this transaction. */
  TxnNumber?: number;
  /** A vendor is any person or company from whom a small business owner buys goods and services. (Banks and tax agencies usually are included on the vendor list.) A company’s vendor list contains information such as account balance and contact information about each vendor. A `VendorRef` aggregate refers to one of the vendors on the list. In a request, if a `VendorRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorRef: VendorRef;
  /** Refers to an accounts payable account in the QuickBooks file. (The `AccountType` of this account will be `AccountsPayable`.)

  If `APAccountRef` is missing, the SDK will use the QuickBooks default AP account. In a request, if an `APAccountRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  APAccountRef?: APAccountRef;
  /** The date of the transaction. In some cases, if you leave `TxnDate` out of an -Add message, QuickBooks will prefill `TxnDate` with the date of the last-saved transaction of the same type. */
  TxnDate: string;
  /** The amount of a credit that is being applied to a vendor bill, reducing the amount that is owed on the bill. */
  CreditAmount: string;
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code.

  When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** The exchange rate is the market price for which this currency can be exchanged for the currency used by the QuickBooks company file as the “home” currency. The exchange rate should be considered a snapshot of the rates in effect at the `AsOfDate`.

  You can update the exchange rate using the exchange rate property when you add a transaction. However, you need to obtain and supply the exchange rate. If you are using USD (United States Dollars) as the home currency and are connected to the Internet, you can download the current exchange rates for all active currencies automatically in the QuickBooks UI by selecting Lists->Currency->Activities->Download latest exchange rates. (Currently, you can’t do this in the SDK.) */
  ExchangeRate?: number;
  /** The amount of the credit, expressed in units of the current home currency. */
  CreditAmountInHomeCurrency?: string;
  /** A string of characters that refers to this transaction and that can be arbitrarily changed by the QuickBooks user.

  In a `BillPaymentCheckAdd` request, if you want to set the check number, use `RefNumber`.

  Note (especially relevant to `CheckAdd` requests): When `RefNumber` is left blank in an SDK transaction add request (that is, or ), the `RefNumber` will be left blank in QuickBooks. This behavior is new as of QBFC3. It used to select the next sequential reference number since the last one used by QuickBooks, as though no `RefNumber` had been provided. This is especially relevant to `CheckAdd` requests because with the current behavior, you will not know the number until the check is printed. */
  RefNumber?: string;
  /** Appears in the A/P register and in reports that include this credit. */
  Memo?: string;
  /** For future use with international versions of QuickBooks. */
  IsTaxIncluded?: boolean;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default: Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false) Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true)

  A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales.

  A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** If the `IncludeLinkedTxns` flag is set to true in a query, or if you create an item receipt that links to other transactionsthen the returned object will include a list of linked transactions, if any exist. If no linked transactions exist, the `ILinkedTxnList` object will be empty.

  The list of linked transactions is similar to the History view of a transaction in the user interface, but not identical, as the SDK list contains only linked transactions, not items. */
  LinkedTxn?: LinkedTxn | LinkedTxn[];
  /** A list of `IExpenseLine` objects, each representing one line in this expense. */
  ExpenseLineRet?: ExpenseLineRet | ExpenseLineRet[];
  /** An `ItemLine` is used to track any portion of a transaction that represents the purchase of an “item.” If `ItemLineAdd` does not specify an `Amount`, `Cost`, or `Quantity`, then QuickBooks will calculate `Amount` based on a `Quantity` of 1 and the suggested `Cost`. */
  ItemLineRet?: ItemLineRet | ItemLineRet[];
  /** Refers to items that are grouped together in QuickBooks for fast entry. */
  ItemGroupLineRet?: ItemGroupLineRet | ItemGroupLineRet[];
  /** Indicates the amount that is still owed. `AmountDue` minus any credits or discounts equals the `OpenAmount`. */
  OpenAmount?: string;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface VendorMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Email address that would be carbon copied or CC. */
  Cc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** A list of contact records. */
  ContactsMod?: ContactsMod | ContactsMod[];
  /** The vendor’s name as it will appear on checks sent to the vendor. (Corresponds in the QuickBooks user interface to the “Print on Check as” field of the Edit Vendor and New Vendor windows.) */
  NameOnCheck?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information about this vendor. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotesMod?: AdditionalNotesMod | AdditionalNotesMod[];
  /** Vendor types allow business owners to categorize vendors in ways that are meaningful for their businesses. For example, a vendor type might indicate which industry a vendor represents, or which part of the country a vendor is in. A `VendorTypeRef` aggregate refers to one of the types on the `VendorType` list. In a request, if a `VendorTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorTypeRef?: VendorTypeRef;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** Set and returned as a positive number that indicates a customer’s or vendor’s credit limit. If no value has been defined, there is no credit limit. */
  CreditLimit?: string;
  /** A character string that identifies a vendor. */
  VendorTaxIdent?: string;
  /** If `IsVendorEligibleFor1099` is set to true, `VendorTaxIdent` and `VendorAddress` are required in a vendor add request message. Otherwise, `VendorTaxIdent` and `VendorAddress` are optional. */
  IsVendorEligibleFor1099?: boolean;
  /** Billing rates are used to override the service item rate in a time transaction (`TimeTrackingAdd`) based on the employee or vendor performing the work. Billing rates are assigned to an employee or a vendor to specify overrides to service items. */
  BillingRateRef?: BillingRateRef;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The country that sales tax is collected for. */
  SalesTaxCountry?: SalesTaxCountry;
  /** Indicates whether the entity is a sales tax agency. */
  IsSalesTaxAgency?: boolean;
  /** Sales tax return information. */
  SalesTaxReturnRef?: SalesTaxReturnRef;
  /** The tax registration number used in CA and UK. */
  TaxRegistrationNumber?: string;
  /** Vendor reporting period for CA or UK. This can be monthly or quarterly. */
  ReportingPeriod?: ReportingPeriod;
  /** This flag is used for CA or UK and whether tax is tracked on purchases. */
  IsTaxTrackedOnPurchases?: boolean;
  /** Account used for taxes on purchases in CA or UK. */
  TaxOnPurchasesAccountRef?: TaxOnPurchasesAccountRef;
  /** This flag is used for CA or UK and whether tax is tracked on sales. */
  IsTaxTrackedOnSales?: boolean;
  /** Account used for taxes on sales in CA or UK. */
  TaxOnSalesAccountRef?: TaxOnSalesAccountRef;
  /** For vendor in CA or UK, is there tax charged on top of tax. */
  IsTaxOnTax?: boolean;
  /** Expense account to prefill when you enter bills for this vendor. */
  PrefillAccountRef?: PrefillAccountRef | PrefillAccountRef[];
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
}

export interface VendorModRq {
  VendorMod: VendorMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VendorModRs {
  VendorRet?: VendorRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VendorQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** Filters according to total balance. Total balance includes the balance for all subaccounts; for example, a customer’s `TotalBalance` would include all the jobs for that customer. */
  TotalBalanceFilter?: TotalBalanceFilter;
  /** Filters by the specified currency. */
  CurrencyFilter?: CurrencyFilter;
  /** Filter according to class. */
  ClassFilter?: ClassFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
  /** Zero or more `OwnerID` values. `OwnerID` refers to the owner of a data extension:If `OwnerID` is 0, this is a public data extension, also known as a custom field. Custom fields appear in the QuickBooks UI.If `OwnerID` is a GUID, for example `{6B063959-81B0-4622-85D6-F548C8CCB517}`, this field is a private data extension defined by an integrated application. Private data extensions do not appear in the QuickBooks UI. Note that `OwnerID` values are not case-sensitive, meaning that if you enter an `OwnerID` value with lower-case letters, the value will be saved and returned with upper-case letters. When you share a private data extension with another application, the other application must know both the `OwnerID` and the `DataExtName`, as these together form a data extension’s unique name. */
  OwnerID?: string[] | string;
}

export interface VendorQueryRs {
  VendorRet: VendorRet[];
}

export interface VendorRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface VendorRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** Classes can be used to separate transactions into meaningful categories. (For example, transactions could be classified according to department, business location, or type of work.) In QuickBooks, class tracking is off by default. A `ClassRef` aggregate refers to one of these named classes. For example, in a `TimeTracking` message, `ClassRef` refers to the QuickBooks class into which the timed activity falls. If a `ClassRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In an `InvoiceAdd` request, if you specify a `ClassRef` for the whole invoice, that same `ClassRef` is automatically used in the line items. If you want to clear that (that is, have NO `ClassRef` for the line item, you can clear it in the line item by simply not specifying it in the line item. */
  ClassRef?: ClassRef;
  /** Is the current entity a tax agency. */
  IsTaxAgency?: boolean;
  /** The name of the QuickBooks user’s business, as specified in QuickBooks. `CompanyName` and `Address` are used on invoices, checks, and other forms. (`LegalCompanyName` and `LegalAddress`, on the other hand, are used on a company’s tax forms and pay stubs.) */
  CompanyName?: string;
  /** A formal reference, such as Mr. or Dr., that precedes a name. */
  Salutation?: string;
  /** The first name of a customer, vendor, employee, or person on the “other names” list. */
  FirstName?: string;
  /** The middle name of a customer, vendor, employee, or person on the “other names” list. */
  MiddleName?: string;
  /** The last name of a customer, vendor, employee, or person on the “other names” list. */
  LastName?: string;
  /** The job title of a customer, vendor, employee, or person on the “other names” list. */
  JobTitle?: string;
  /** If an address request fails, some combination of address fields might be too long. */
  VendorAddress?: VendorAddress;
  /** The address expressed as an address block of `Addr1` through `Addr5`, depending on the number of lines in the original request that created the address. */
  VendorAddressBlock?: VendorAddressBlock;
  /** Whatever address you specify in this aggregate must not result in an address greater than 5 lines, otherwise you’ll get a runtime error, because QuickBooks doesn’t support addresses more than 5 lines. There are two ways to specify an address within this aggregate: Using `Addr1` through `Addr3` along with the other possible aggregate elements, such as `City`, `State`, Postalcode.Using `Addr1`, `Addr2`, `Addr3`, `Addr4`, and `Addr5` to fully specify the address. If you use this so called “address block” approach, you cannot use any other address elements, such as `City`, `State`, etc. (Note: this approach is not valid for `EmployeeAdd`/Mod/Query) If you use the address block approach above, the lines `Addr1`…`Addr5` are each printed as a separate line on the transaction, and the values are returned in the Ret object under the aggregate `ShipAddressBlock` or `BillAddressBlock`. */
  ShipAddress?: ShipAddress;
  /** The telephone number. */
  Phone?: string;
  /** A telephone number given as an alternative to `Phone`. */
  AltPhone?: string;
  /** Fax number. */
  Fax?: string;
  /** E-mail address. */
  Email?: string;
  /** Email address that would be carbon copied or CC. */
  Cc?: string;
  /** The name of a contact person for a customer or vendor. */
  Contact?: string;
  /** The name of an alternate contact person for a vendor, customer, or “other name” entry. */
  AltContact?: string;
  /** List of additional contacts. */
  AdditionalContactRef?: AdditionalContactRef | AdditionalContactRef[];
  /** A list of contact records. */
  ContactsRet?: ContactsRet | ContactsRet[];
  /** The vendor’s name as it will appear on checks sent to the vendor. (Corresponds in the QuickBooks user interface to the “Print on Check as” field of the Edit Vendor and New Vendor windows.) */
  NameOnCheck?: string;
  /** Account numbers appear in the QuickBooks chart of accounts, Account fields, and reports and graphs. If the `IsUsingAccountNumber` preference is false (that is, if the QuickBooks user has the account numbers Preference turned off), you can still set account numbers through the SDK, but the numbers will not be visible in the user interface. */
  AccountNumber?: string;
  /** Additional information about this vendor. */
  Notes?: string;
  /** List of notes. */
  AdditionalNotesRet?: AdditionalNotesRet | AdditionalNotesRet[];
  /** Vendor types allow business owners to categorize vendors in ways that are meaningful for their businesses. For example, a vendor type might indicate which industry a vendor represents, or which part of the country a vendor is in. A `VendorTypeRef` aggregate refers to one of the types on the `VendorType` list. In a request, if a `VendorTypeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  VendorTypeRef?: VendorTypeRef;
  /** Refers to the payment terms associated with this entity. (This will be an item on the `DateDrivenTerms` or `StandardTerms` list.) If a `TermsRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  TermsRef?: TermsRef;
  /** Set and returned as a positive number that indicates a customer’s or vendor’s credit limit. If no value has been defined, there is no credit limit. */
  CreditLimit?: string;
  /** A character string that identifies a vendor. */
  VendorTaxIdent?: string;
  /** If `IsVendorEligibleFor1099` is set to true, `VendorTaxIdent` and `VendorAddress` are required in a vendor add request message. Otherwise, `VendorTaxIdent` and `VendorAddress` are optional. */
  IsVendorEligibleFor1099?: boolean;
  /** A positive number indicates money owed to this vendor. */
  Balance?: string;
  /** Billing rates are used to override the service item rate in a time transaction (`TimeTrackingAdd`) based on the employee or vendor performing the work. Billing rates are assigned to an employee or a vendor to specify overrides to service items. */
  BillingRateRef?: BillingRateRef;
  /** Allows for the attachment of a user defined GUID value. */
  ExternalGUID?: string;
  /** Each item on a sales form is assigned a sales-tax code that indicates whether the item is taxable or non-taxable, and why. Two general codes, which can be modified but not deleted, appear on the sales-tax code list by default:Non-taxable (`Name` = NON; `Desc` = Non-Taxable; `IsTaxable` = false)Taxable (`Name` = TAX; `Desc` = Taxable; `IsTaxable` = true) A sales-tax code can be deleted only if it is no longer associated with any customer, item, or transaction. If the “Do You Charge Sales Tax?” preference within QuickBooks is set to No, QuickBooks will assign the default non-taxable sales-tax code to all sales. A `SalesTaxCodeRef` aggregate refers to a sales-tax code on the list. In a request, if a `SalesTaxCodeRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. In a Customer message, `SalesTaxCodeRef` refers to the sales-tax code that will be used for items related to this customer. In an `ItemInventory` message, `SalesTaxCodeRef` refers to the type of sales tax that will be charged for this item, if it is a taxable item and if sales tax is set up within QuickBooks. */
  SalesTaxCodeRef?: SalesTaxCodeRef;
  /** The country that sales tax is collected for. */
  SalesTaxCountry?: SalesTaxCountry;
  /** Indicates whether the entity is a sales tax agency. */
  IsSalesTaxAgency?: boolean;
  /** Sales tax return information. */
  SalesTaxReturnRef?: SalesTaxReturnRef;
  /** The tax registration number used in CA and UK. */
  TaxRegistrationNumber?: string;
  /** Vendor reporting period for CA or UK. This can be monthly or quarterly. */
  ReportingPeriod?: ReportingPeriod;
  /** This flag is used for CA or UK and whether tax is tracked on purchases. */
  IsTaxTrackedOnPurchases?: boolean;
  /** Account used for taxes on purchases in CA or UK. */
  TaxOnPurchasesAccountRef?: TaxOnPurchasesAccountRef;
  /** This flag is used for CA or UK and whether tax is tracked on sales. */
  IsTaxTrackedOnSales?: boolean;
  /** Account used for taxes on sales in CA or UK. */
  TaxOnSalesAccountRef?: TaxOnSalesAccountRef;
  /** For vendor in CA or UK, is there tax charged on top of tax. */
  IsTaxOnTax?: boolean;
  /** Expense account to prefill when you enter bills for this vendor. */
  PrefillAccountRef?: PrefillAccountRef | PrefillAccountRef[];
  /** The currency object contains all of the information needed by QuickBooks to display and use. For built-in currencies, the name and currency code values are internationally accepted values and thus are not editable. The comma format is editable, as is the `IsActive` status. For user-defined currencies, every value in the object is editable including name and currency code. When used with `PriceLevels`, the `CurrencyRef` should only be used with “per item” price levels. */
  CurrencyRef?: CurrencyRef;
  /** A list of `IDataExtRet` objects, each of which represents a field that has been added to QuickBooks as a data extension. */
  DataExtRet?: DataExtRet | DataExtRet[];
}

export interface VendorTypeAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen.

  For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
}

export interface VendorTypeAddRq {
  VendorTypeAdd: VendorTypeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VendorTypeAddRs {
  VendorTypeRet?: VendorTypeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface VendorTypeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.`Note`: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface VendorTypeQueryRs {
  VendorTypeRet: VendorTypeRet[];
}

export interface VendorTypeRef {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string;
}

export interface VendorTypeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** Time the object was created. */
  TimeCreated: string;
  /** Time the object was last modified. */
  TimeModified: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen.

  For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A reference to the list object that is one level above this one. For example, an inventory item with the `FullName` of `GermanCars`:Mercedes-Benz:`CL500I99AA` might have a parent object with the `FullName` of `GermanCars`:Mercedes-Benz. In a request, if a `ParentRef` aggregate includes both `FullName` and `ListID`, `FullName` will be ignored. */
  ParentRef?: ParentRef;
  /** The number of ancestors. For example, The customer job with `Name` = carpets and `FullName` = Jones:Building2:carpets would have a sublevel of 2. */
  Sublevel: number;
}

export type WageType =
  | "Bonus"
  | "Commission"
  | "HourlyOvertime"
  | "HourlyRegular"
  | "HourlySick"
  | "HourlyVacation"
  | "SalaryRegular"
  | "SalarySick"
  | "SalaryVacation";

export interface WorkersCompCodeAdd {
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A descriptive text field. */
  Desc?: string;
  /** A `RateEntry` consists of one rate and one effective date. You can have as many rate entries as you like, but you must add each one to the `RateEntry` list like this: Dim `MyRateEntry` As `IRateEntry` Set `MyRateEntry` = My_IWorkersCompCodeAdd_object.`RateEntryList`.Append `MyRateEntry`.`EffectiveDate`.`SetValue` #7/7/2007 9:35:00 AM#” `MyRateEntry`.`Rate`.`SetValue` 1# */
  RateEntry: RateEntry | RateEntry[];
}

export interface WorkersCompCodeAddRq {
  WorkersCompCodeAdd: WorkersCompCodeAdd;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface WorkersCompCodeAddRs {
  WorkersCompCodeRet?: WorkersCompCodeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface WorkersCompCodeMod {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen. For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A descriptive text field. */
  Desc?: string;
  /** A `RateEntry` consists of one rate and one effective date. You can have as many rate entries as you like, but you must add each one to the `RateEntry` list like this: Dim `MyRateEntry` As `IRateEntry` Set `MyRateEntry` = My_IWorkersCompCodeAdd_object.`RateEntryList`.Append `MyRateEntry`.`EffectiveDate`.`SetValue` #7/7/2007 9:35:00 AM#” `MyRateEntry`.`Rate`.`SetValue` 1# */
  RateEntry?: RateEntry | RateEntry[];
}

export interface WorkersCompCodeModRq {
  WorkersCompCodeMod: WorkersCompCodeMod;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address. The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name. Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface WorkersCompCodeModRs {
  WorkersCompCodeRet?: WorkersCompCodeRet;
  ErrorRecovery?: ErrorRecovery;
}

export interface WorkersCompCodeQueryRq {
  /** One or more `ListID` values. Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`.

  A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string[] | string;
  /** A list of one or more `FullName` values. `FullName` (along with `ListID`) is a way to identify a list object. The `FullName` is the name prefixed by the names of each ancestor, for example `Jones:Kitchen:Cabinets`. `FullName` values are not case-sensitive. */
  FullName?: string[] | string;
  /** Limits the number of objects that a query returns. (To get a count of how many objects could possibly be returned, use the `metaData` query attribute.) If you include a `MaxReturned` value, it must be at least 1. */
  MaxReturned?: number;
  /** Used in filters to select list objects based on whether or not they are currently enabled for use by QuickBooks. The default value is `asActiveOnly`, which selects only list objects that are active. */
  ActiveStatus?: ActiveStatus;
  /** Selects objects modified on or after this date. See the note below regarding QBFC usage.

  For desktop versions of QuickBooks, the `FromModifiedDate` and `ToModifiedDate` must be between 1970-01-01 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (The time portion of the field was not supported in qbXML version 1.0 or 1.1.) Also, for desktop versions of QuickBooks, if `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1970-01-01T00:00:00 (1969-12-31T16:00:00-08:00 PST).

  For QBOE, the `FromModifiedDate` and `ToModifiedDate` must be between 1900-01-01T00:00:00 and 9999-12-31T00:00:00. If `FromModifiedDate` includes a date but not a time (for example, if you set `FromModifiedDate` to 2003-02-14), the time is assumed to be zero (2003-02-14T00:00:00). If you omit `FromModifiedDate`, it will be set to 1900-01-01T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  FromModifiedDate?: string;
  /** Selects objects modified on or before this date. See the note below on QBFC usage.

  For desktop versions of QuickBooks, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1970 and 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST). (Note that the time portion of the field was not supported in qbXML version 1.0 or 1.1.) If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 2038-01-19T03:14:07 (2038-01-18T19:14:07-08:00 PST).

  For QBOE, the `ToModifiedDate` and `FromModifiedDate` must be between 01/01/1900 and 9999-12-31T00:00:00. If `ToModifiedDate` includes a date but not a time (for example, if you set `ToModifiedDate` to 2003-02-14), the time is assumed to be the end of the day (2003-02-14T23:59:59). If you omit `ToModifiedDate` altogether, it will be set to 9999-12-31T00:00:00.

  Note: When specifying this in QBFC, you need to supply the parameter `asDateOnly`, which is a Boolean. If `asDateOnly` is true, the date value will be represented as a date only (without a time). If `asDateOnly` is false, the date value will be represented as date and time, padded with zeros if necessary, and set to the beginning of the day if no time is provided. The `asDateOnly` parameter is especially useful in the `ToModifiedDate` field of a query: If `asDateOnly` is set to true in the `ToModifiedDate` field of a query, then the query includes elements modified up to the end of the day. If `asDateOnly` is false, the query includes elements modified up to the specified time (or up to the beginning of the day if no time is included). */
  ToModifiedDate?: string;
  /** Filters according to the object’s `Name`. */
  NameFilter?: NameFilter;
  /** Filters according to the object’s `Name`. */
  NameRangeFilter?: NameRangeFilter;
  /** The beginning of the range of effective dates to be searched. */
  FromEffectiveDate?: string;
  /** The end of the range of effective dates to be searched. */
  ToEffectiveDate?: string;
  /** You use this if you want to limit the data that will be returned in the response. In this list, you specify the name of each top-level element or aggregate that you want to be returned in the response to the request. You cannot specify fields within an aggregate, for example, you cannot specify a `City` within an `Address`: you must specify `Address` and will get the entire address.

  The names specified in the list are not parsed, so you must be especially careful to supply valid names, properly cased. No error is returned in the status code if you specify an invalid name.

  Notice that if you want to return custom data or private data extensions, you must specify the `DataExtRet` element and you must supply the `OwnerID` set to either a value of 0 (custom data) or the GUID for the private data. */
  IncludeRetElement?: string[] | string;
}

export interface WorkersCompCodeQueryRs {
  WorkersCompCodeRet: WorkersCompCodeRet[];
}

export interface WorkersCompCodeRet {
  /** Along with `FullName`, `ListID` is a way to identify a list object. When a list object is added to QuickBooks through the SDK or through the QuickBooks user interface, the server assigns it a `ListID`. A `ListID` is not unique across lists, but it is unique across each particular type of list. For example, two customers could not have the same `ListID`, and a customer could not have the same `ListID` as an employee (because Customer and Employee are both name lists). But a customer could have the same `ListID` as a non-inventory item. */
  ListID?: string;
  /** Time the object was created. */
  TimeCreated?: string;
  /** Time the object was last modified. */
  TimeModified?: string;
  /** A number that the server generates and assigns to this object. Every time the object is changed, the server will change its `EditSequence` value. When you try to modify a list object, you must provide its `EditSequence`. The server compares the `EditSequence` you provide with the `EditSequence` in memory to make sure you are dealing with the latest copy of the object. If you are not, the server will reject the request and return an error. Because `EditSequence` is only used to check whether two objects match, there is no reason to interpret its value. */
  EditSequence?: string;
  /** The case-insensitive name of a list object, not including the names of its ancestors. `Name` must be unique, unless it is the `Name` of a “hierarchical” list object. List objects in different hierarchies can have duplicate names because their `FullNames` will still be unique. For example, two objects could both have the `Name` kitchen, but they could have unique `FullNames`, such as Job12:kitchen and Baker:kitchen.

  For built-in currencies, `Name` is the internationally accepted currency name and is not editable. */
  Name?: string;
  /** If `IsActive` is true, this object is currently enabled for use by QuickBooks. The default value is true. */
  IsActive?: boolean;
  /** A descriptive text field. */
  Desc?: string;
  /** Indicates the workers’ comp insurance premium rate that is currently in effect for the current comp code. If the code doesn’t have a current effective date–that is, it has a future date only, then this field is empty. */
  CurrentRate?: string;
  /** Indicates the date at which the workers’ compensation code went into effect. This field contains a value only if the code is currently in effect. If the code has only a future date, then this field is empty. */
  CurrentEffectiveDate?: string;
  /** You can create a workers’ comp code with several rates and effective dates, both in the past, present, and future (only one in the future). Each of these dates has a rate associated with it, the idea being you can set up the comp code to support anticipated increases (or decreases) in the rate. The value in this field indicates the first rate that will occur after the current rate andeffective date. */
  NextRate?: string;
  /** You can create a workers’ comp code with several rates and effective dates, both in the past, present, and future (only one in the future). Each of these dates has a rate associated with it, the idea being you can set up the comp code to support anticipated increases (or decreases) in the rate. The value in this field indicates the first effective date that will occur after the current effective date. */
  NextEffectiveDate?: string;
  /** The rate history is returned in Workers Comp Code Add and Query responses. There will be one `RateHistory` returned for each rate entry in the comp code. Each `RateHistory` aggregate consists of an effective date and a rate. */
  RateHistory?: RateHistory | RateHistory[];
}
